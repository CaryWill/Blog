<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta charset="utf-8" />
	<link rel="stylesheet" type="text/css" href="/css/style.css" />
	<title>Regular Expression 101</title>
</head>

<body>
	<h1>Regular Expression 101</h1>

	<p><strong>By cary / Sep 1, 2021</strong></p>

	<p><strong>Reg</strong>ular <strong>Exp</strong>ression 简称 regex or
		regexp。根据匹配的精准度可以将 regex
		分为<strong>模糊匹配</strong>和<strong>精确匹配</strong>。</p>

	<h2>模糊匹配</h2>

	<h3>Literals</h3>

	<p><strong>a</strong> 就是 <strong>a</strong>，<strong>b</strong> 就是
		<strong>b</strong>。</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/b/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;abc&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>

	<p>还有一种方式可以表示<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes">Literals</a>，就是
		unicode code point，根据范围不一样可以分为以下3种，</p>

	<ol>
		<li><code>\xhh</code>。

			<blockquote>
				<p>Matches the character with the code hh (two
					hexadecimal digits).</p>
			</blockquote>

			<p>匹配 unicode code point 在 U+0000 和 U+00FF (the Basic
				Latin and Latin-1 Supplement blocks; equivalent
				to ISO-8859-1) 之间的字符。</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\x41/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;A&#39;</span>)</code></pre>
		</li>
		<li><code>\uhhhh</code>。

			<blockquote>
				<p>Matches a UTF-16 code-unit with the value
					hhhh (four hexadecimal digits).</p>
			</blockquote>

			<p>就是匹配 unicode code point 在 U+0000 和 U+FFFF (the
				Unicode Basic Multilingual Plane) 之间的字符。</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\u0041/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;A&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/\u1f926/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;🤦&#39;</span>) <span class="syntax-all syntax-comment">// 只支持四位数
</span></code></pre>
		</li>
		<li><code>\u{hhhhh}</code>和 <code>\u{hhhh}</code>。

			<blockquote>
				<p>(Only when the u flag is set.) Matches the
					character with the Unicode value U+hhhh
					or U+hhhhh (hexadecimal digits).</p>
			</blockquote>

			<p><code>\u{hhhh}</code> 的话，效果和 <code>\uhhhh</code> 一样。
			</p>

			<p><code>/\u{hhhhh}/</code> 的话，匹配 unicode code point
				在做U+0000 和 U+10FFFF (the entirety of
				Unicode)之间的字符。</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\u{0041}/</span><span class="syntax-all syntax-parameter">u</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;A&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/\u{0041}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;A&#39;</span>) <span class="syntax-all syntax-comment">// false
</span><span class="syntax-all syntax-string">/\u{1f926}/</span><span class="syntax-all syntax-parameter">u</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;🤦&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>
		</li>
	</ol>

	<p><code>\u{hhhhh}</code> 和 <code>\u{hhhh}</code> 操作符要注意一点，需要带上 <strong>
			u</strong> flag，不然会和 <code>x{n}</code>
		操作符有歧义，<code>x{n}</code> 量词操作符后面会讲解。</p>

	<p>关于更多的 unicode 的知识点，将在另一篇博客中进行详细讲解，本文不做赘述。</p>

	<h3>Special character</h3>

	<p><strong>. </strong> 不是 <strong>. </strong>，<strong>?</strong> 不是
		<strong>?</strong>。</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/?/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;?&#39;</span>) <span class="syntax-all syntax-comment">// Uncaught SyntaxError: Invalid regular expression: /?/: Nothing to repeat
</span><span class="syntax-all syntax-string">/./</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;.&#39;</span>) <span class="syntax-all syntax-comment">// true // 虽然是 true，但是你要知道，/./ 表示匹配所有的字符除了 line terminators，所以才匹配上的
</span></code></pre>

	<p>一些字符在 regex 中具有特殊意义。就比如我们上面例子里 <code>/./</code> 的
		<strong>.</strong>，来看下它的<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes">定义</a>，
	</p>

	<blockquote>
		<p>Has one of the following meanings:</p>

		<ul>
			<li>Matches any single character except line
				terminators: \n, \r, \u2028 or \u2029. For
				example, /.y/ matches "my" and "ay", but not
				"yes", in "yes make my day".</li>
			<li>Inside a character class, the dot loses its special
				meaning and matches a literal dot.</li>
		</ul>

		<p>Note that the m multiline flag doesn't change the dot
			behavior. So to match a pattern across multiple lines,
			the character class [^] can be used — it will match any
			character including newlines.</p>

		<p>ES2018 added the s "dotAll" flag, which allows the dot to
			also match line terminators.</p>
	</blockquote>

	<p>如果你想让 <strong>.</strong> 变成普通的字符，那么你只能通过 <code>\</code>
		操作符来对这个字符进行转义，但是 <strong>.</strong> 操作符有点特殊，根据定义你还可以使用
		<code>[xyz]</code> 操作符将 <strong>.</strong>
		变成字面量（literal），也就是普通字符。</p>

	<p>首先我们来看下 <code>\</code> 的<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes">定义</a>，
	</p>

	<blockquote>
		<p>Indicates that the following character should be treated
			specially, or "escaped". It behaves one of two ways.</p>

		<ul>
			<li> For characters that are usually treated literally,
				indicates that the next character is special and
				not to be interpreted literally. For example,
				/b/ matches the character "b". By placing a
				backslash in front of "b", that is by using
				/\b/, the character becomes special to mean
				match a word boundary.</li>
			<li> For characters that are usually treated specially,
				indicates that the next character is not special
				and should be interpreted literally. For
				example, "*" is a special character that means 0
				or more occurrences of the preceding character
				should be matched; for example, /a*/ means match
				0 or more "a"s. To match * literally, precede it
				with a backslash; for example, /a\*/ matches
				"a*". </li>
		</ul>

		<p>Note: To match this character literally, escape it with
			itself. In other words to search for \ use /\\/.</p>
	</blockquote>

	<p>这里因为 <strong>.</strong> 是一个特殊字符，所以我们可以通过 <code>\</code>
		来进行转义以取消它的特殊性，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/./</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;1.1&#39;</span>) <span class="syntax-all syntax-comment">// always true
</span><span class="syntax-all syntax-string">/\./</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;1.1&#39;</span>) <span class="syntax-all syntax-comment">// true // right way 
</span><span class="syntax-all syntax-string">/\./</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;11&#39;</span>) <span class="syntax-all syntax-comment">// false
</span></code></pre>

	<p>只是因为 <strong>.</strong> 比较特殊，所以你通过 <code>[xyz]</code> 操作符来将它变成字面量，来看下
		<code>[xyz]</code> 操作符的<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges">定义</a>，
	</p>

	<blockquote>
		<p>A character class. Matches any one of the enclosed
			characters. You can specify a range of characters by
			using a hyphen, but if the hyphen appears as the first
			or last character enclosed in the square brackets it is
			taken as a literal hyphen to be included in the
			character class as a normal character.</p>

		<p>For example, [abcd] is the same as [a-d]. They match the "b"
			in "brisket", and the "c" in "chop".</p>

		<p>For example, [abcd-] and [-abcd] match the "b" in "brisket",
			the "c" in "chop", and the "-" (hyphen) in "non-profit".
		</p>

		<p>For example, [\w-] is the same as [A-Za-z0-9_-]. They both
			match the "b" in "brisket", the "c" in "chop", and the
			"n" in "non-profit".</p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/[.]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;1.1&#39;</span>) <span class="syntax-all syntax-comment">// true // right way
</span><span class="syntax-all syntax-string">/[.]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;11&#39;</span>) <span class="syntax-all syntax-comment">// false
</span></code></pre>

	<p><strong>A character class</strong> 顾名思义就是一类字符，如下面的
		<code>[123]</code>，只要你的字符串里有 1 或者2或者3，不要求你的字符串一定等于
		<strong>123</strong>，只要匹配上一个字符就算匹配了，<strong>一类字符</strong>说白了还是匹配一个字符，
	</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/[123]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;11&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>

	<h3> Not Match a character</h3>

	<p>我们有想上班的时候，就会有不想上班的时候，匹配也是一样。什么？你想上班？上面我们提到了我们可以使用 <code>[xyz]</code>
		操作符来匹配某一类字符，也可以使用 <code>[^xyz]</code> 来不匹配某一类字符，让我们来看下它的<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges">定义</a>，
	</p>

	<blockquote>
		<p>A negated or complemented character class. That is, it
			matches anything that is not enclosed in the brackets.
			You can specify a range of characters by using a hyphen,
			but if the hyphen appears as the first or last character
			enclosed in the square brackets it is taken as a literal
			hyphen to be included in the character class as a normal
			character. For example, [^abc] is the same as [^a-c].
			They initially match "o" in "bacon" and "h" in "chop".
		</p>

		<p>Note: The ^ character may also indicate the beginning of
			input.</p>
	</blockquote>

	<p>意思就是，只要我们的字符串里有一个字符不在这一类字符里面，那么就表示不匹配成功了，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/[^xyz]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;xab&#39;</span>) <span class="syntax-all syntax-comment">// true // a 和 b 不属于 xyz 里面
</span><span class="syntax-all syntax-string">/[^xyz]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;xyz&#39;</span>) <span class="syntax-all syntax-comment">// false // xyz 和 xyz 相等
</span></code></pre>

	<h3> Character class</h3>

	<p>一类字符。上面我们提到了 <code>[xyz]</code>
		操作符可以定义一类字符用来匹配，比如我们想匹配阿拉伯数字，那么我们可以这样写，<code>[0123456789]</code>
		或者 <code>[0-9]</code>，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/[0123456789]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;t3st&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/[0-9]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;t3st&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/[0123456789]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;test&#39;</span>) <span class="syntax-all syntax-comment">// false
</span></code></pre>

	<p>这么常用的操作，正字表达式里有语法糖吗？还真有，它内置了一些 character class，比如上面的
		<code>[0-9]</code> 或者 <code>[0123456789]</code> 可以用
		<code>\d</code> 来代替， 其<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes">定义</a>如下：
	</p>

	<blockquote>
		<p>Matches any digit (Arabic numeral). Equivalent to [0-9]. For
			example, /\d/ or /[0-9]/ matches "2" in "B2 is the suite
			number".</p>
	</blockquote>

	<p>d 就是 digit 的意思。</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\d/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;t3st&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>

	<p><code>/[^0-9]/</code>，那么不匹配阿拉伯数字呢？也有对应的语法糖，<code>\D</code>，和
		<code>\d</code> 对应，正好是大小写关系，定义如下，</p>

	<blockquote>
		<p>Matches any character that is not a digit (Arabic numeral).
			Equivalent to [^0-9]. For example, /\D/ or /[^0-9]/
			matches "B" in "B2 is the suite number".</p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\D/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;test&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/\D/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;123&#39;</span>) <span class="syntax-all syntax-comment">// false
</span></code></pre>

	<hr />

	<p>除了上面这两个 character class 其他的 character class 也非常实用，</p>

	<ol>
		<li><code>\w</code>。匹配24个字母和数字外加一个下划线。

			<blockquote>
				<p>Matches any alphanumeric character from the
					basic Latin alphabet, including the
					underscore. Equivalent to [A-Za-z0-9_].
					For example, /\w/ matches "a" in
					"apple", "5" in "$5.28", "3" in "3D" and
					"m" in "Émanuel".</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;abc def&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\w/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] // 没有匹配空格 
</span></code></pre>

			<p>上面的 <code>/\w/g</code> 里面的 <strong>g</strong>
				的意思是匹配所有字符，这个后面会讲解，现在只需要理解下意思就行。</p>
		</li>
		<li><code>\W</code>。不匹配24个字母和数字外加一个下划线。

			<blockquote>
				<p>Matches any character that is not a word
					character from the basic Latin alphabet.
					Equivalent to [^A-Za-z0-9_]. For
					example, /\W/ or /[^A-Za-z0-9_]/ matches
					"%" in "50%" and "É" in "Émanuel".</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;abc def&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\W/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39; &#39;] // 匹配了个空格
</span></code></pre>
		</li>
		<li><code>\s</code>。匹配一个空格字符(white space character)。

			<blockquote>
				<p>Matches a single white space character,
					including space, tab, form feed, line
					feed, and other Unicode spaces.
					Equivalent to [
					\f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff].
					For example, /\s\w*/ matches " bar" in
					"foo bar".</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;abc def&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\s/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39; &#39;] // 单单只匹配空格字符
</span></code></pre>
		</li>
		<li><code>\S</code>。不匹配一个空格字符(white space character)。

			<blockquote>
				<p>Matches a single character other than white
					space. Equivalent to [^
					\f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff].
					For example, /\S\w*/ matches "foo" in
					"foo bar".</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;abc def&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\S/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] // 除了空格字符，其他都匹配
</span></code></pre>
		</li>
		<li>空格字符(white space character)。

			<pre><code class="code-highlighted code-js">\<span class="syntax-all syntax-string">t</span><span class="syntax-all syntax-constant">:</span> <span class="syntax-all syntax-parameter">Matches</span> <span class="syntax-all syntax-parameter">a</span> <span class="syntax-all syntax-parameter">horizontal</span> <span class="syntax-all syntax-parameter">tab</span><span class="syntax-all syntax-keyword">.</span>
\<span class="syntax-all syntax-string">r</span><span class="syntax-all syntax-constant">:</span> <span class="syntax-all syntax-parameter">Matches</span> <span class="syntax-all syntax-parameter">a</span> <span class="syntax-all syntax-parameter">carriage</span> <span class="syntax-all syntax-keyword">return.</span>
\<span class="syntax-all syntax-string">n</span><span class="syntax-all syntax-constant">:</span> <span class="syntax-all syntax-parameter">Matches</span> <span class="syntax-all syntax-parameter">a</span> <span class="syntax-all syntax-parameter">linefeed</span><span class="syntax-all syntax-keyword">.</span>
\<span class="syntax-all syntax-string">v</span><span class="syntax-all syntax-constant">:</span> <span class="syntax-all syntax-parameter">Matches</span> <span class="syntax-all syntax-parameter">a</span> <span class="syntax-all syntax-parameter">vertical</span> <span class="syntax-all syntax-parameter">tab</span><span class="syntax-all syntax-keyword">.</span>
\<span class="syntax-all syntax-string">f</span><span class="syntax-all syntax-constant">:</span> <span class="syntax-all syntax-parameter">Matches</span> <span class="syntax-all syntax-parameter">a</span> <span class="syntax-all syntax-parameter">form</span><span class="syntax-all syntax-keyword">-</span><span class="syntax-all syntax-parameter">feed</span><span class="syntax-all syntax-keyword">.</span></code></pre>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\n/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\n</span><span class="syntax-all syntax-string">&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/\r/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\r</span><span class="syntax-all syntax-string">&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/\t/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\t</span><span class="syntax-all syntax-string">&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/\v/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\v</span><span class="syntax-all syntax-string">&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/\f/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\f</span><span class="syntax-all syntax-string">&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>

			<p>还记得之前提到的 <code>\</code>
				操作符吗，它可以将特殊字符转移成普通字符，也可以将普通字符转移成特殊字符，比如，<strong>r</strong>，没有任何特殊含义，那么转义下它，
				<code>\r</code>，它就表示回车字符了。 还有 <code>\</code>
				本身是特殊字符，如果你想匹配它本身的话，那么就得转义它自己，<code>\\</code>，
			</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\\/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\\</span><span class="syntax-all syntax-string">&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/\\r/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\\</span><span class="syntax-all syntax-string">r&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>
		</li>
		<li><code>\p{UnicodeProperty}</code>。可以算作之前的 <code>uhhhh</code>
			等的 character class，匹配一类 unicode，比如匹配表情，

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-parameter">sentence</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&#39;A ticket to 大阪 costs ¥2000 👌.&#39;</span>;
<span class="syntax-all syntax-keyword">const</span> <span class="syntax-all syntax-parameter">regexpEmojiPresentation</span> <span class="syntax-all syntax-keyword">=</span><span class="syntax-all syntax-string"> /\p{Emoji_Presentation}/</span><span class="syntax-all syntax-keyword">g</span><span class="syntax-all syntax-parameter">u</span>;
<span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">sentence</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-parameter">regexpEmojiPresentation</span>));
<span class="syntax-all syntax-comment">// expected output: Array [&quot;👌&quot;]
</span></code></pre>

			<blockquote>
				<p>Matches a character based on its <a
						href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes">Unicode
						character properties</a> (to
					match just, for example, emoji
					characters, or Japanese katakana
					characters, or Chinese/Japanese
					Han/Kanji characters, etc.).</p>
			</blockquote>

			<p>详细的定义如下，</p>

			<blockquote>
				<p>Unicode property escapes Regular Expressions
					allows for matching characters based on
					their Unicode properties. A character is
					described by several properties which
					are either binary ("boolean-like") or
					non-binary. For instance, unicode
					property escapes can be used to match
					emojis, punctuations, letters (even
					letters from specific languages or
					scripts), etc.</p>
			</blockquote>

			<p>用法定义如下，</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-comment">// Non-binary values
</span>\<span class="syntax-all syntax-parameter">p</span>{<span class="syntax-all syntax-parameter">UnicodePropertyValue</span>}
\<span class="syntax-all syntax-parameter">p</span>{<span class="syntax-all syntax-parameter">UnicodePropertyName</span><span class="syntax-all syntax-keyword">=</span><span class="syntax-all syntax-parameter">UnicodePropertyValue</span>}

<span class="syntax-all syntax-comment">// Binary and non-binary values
</span>\<span class="syntax-all syntax-parameter">p</span>{<span class="syntax-all syntax-parameter">UnicodeBinaryPropertyName</span>}

<span class="syntax-all syntax-comment">// Negation: \P is negated \p
</span>\<span class="syntax-all syntax-constant">P</span>{<span class="syntax-all syntax-parameter">UnicodePropertyValue</span>}
\<span class="syntax-all syntax-constant">P</span>{<span class="syntax-all syntax-parameter">UnicodeBinaryPropertyName</span>}</code></pre>

			<p>详细介绍请参考，<a
					href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes">Unicode
					property escapes - MDN</a>。</p>
		</li>
		<li><code>[\b]</code>。<strong>b</strong> 这个字符和
			<strong>.</strong> 字符比较特殊，它们俩在 <code>[xyz]</code>
			操作符中表示字面量，不过也不常用，定义如下。

			<blockquote>
				<p>Matches a backspace. If you're looking for
					the word-boundary character (\b), see
					Assertions.</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/[\b]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;\x08&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/[\b]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\b</span><span class="syntax-all syntax-string">&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>
		</li>
		<li><code>\0</code>。 不常用。

			<blockquote>
				<p>Matches a NUL character. Do not follow this
					with another digit.</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/[\0]/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\0</span><span class="syntax-all syntax-string">&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>
		</li>
		<li><code>\cX</code>。不常用。

			<blockquote>
				<p>Matches a control character using [caret
					notation], where "X" is a letter from
					A–Z (corresponding to codepoints
					U+0001–U+001A). For example, /\cM\cJ/
					matches "\r\n".</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-escape">\r\n</span><span class="syntax-all syntax-string">&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\cM\cJ/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;\r\n&#39;]
</span></code></pre>
		</li>
	</ol>

	<p>到此模糊匹配的教程就结束了。</p>

	<h2>精确匹配</h2>

	<p>根据目标字符串加上额外的匹配条件来精确匹配目标字符。比如我想匹配 <strong>hot</strong> 的
		<strong>o</strong>，而不是 <strong>dog</strong> 的
		<strong>o</strong>，我们就需要用 <strong>o</strong>
		字符前后的字符（串）作为额外的匹配条件来进行精确匹配。</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/(?&lt;=h)o(?=t)/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;hot&#39;</span>) <span class="syntax-all syntax-comment">// true // 专门用来匹配 hot 
</span><span class="syntax-all syntax-string">/(?&lt;=h)o(?=t)/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;dog&#39;</span>) <span class="syntax-all syntax-comment">// false
</span></code></pre>

	<p>上面我们用到了 <code>x(?=y)</code> 和 <code>(?&lt;=y)x</code> 这两个 <a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions">断言</a>（assertions）操作符，来看下它们的定义，
	</p>

	<ol>
		<li><code>x(?=y)</code>。用目标字符 <strong>x</strong>
			后面的字符（串）作为额外匹配条件，

			<blockquote>
				<p>Lookahead assertion: Matches "x" only if "x"
					is followed by "y".</p>
			</blockquote>
		</li>
		<li><code>(?&lt;=y)x</code>。用目标字符 <strong>x</strong>
			前面的字符（串）作为额外匹配条件，

			<blockquote>
				<p>Lookbehind assertion: Matches "x" only if "x"
					is preceded by "y". </p>
			</blockquote>

			<p>但是看上去在写这篇文章的时候， safari 还不支持这个
				<code>(negative) lookbehind assertion</code>操作符，会报错，
			</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/(?&lt;!h)o/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;hot&#39;</span>) <span class="syntax-all syntax-comment">// SyntaxError: Invalid regular expression: invalid group specifier name
</span></code></pre>
		</li>
	</ol>

	<p>记法小窍门：<code>(?&lt;=y)x</code> 操作符里有一个 <strong> &lt;</strong>
		符号，你将它理解为向左看就很好极了。</p>

	<p>上面说的都是等于的情况，当你不想匹配某一个条件的时候，可以使用 <code>x(?!y)</code> 和
		<code>(?&lt;!y)x</code> 操作符，</p>

	<ol>
		<li><code>x(?!y)</code>。

			<blockquote>
				<p>Negative lookahead assertion: Matches "x"
					only if "x" is not followed by "y".</p>
			</blockquote>
		</li>
		<li><code>(?&lt;!y)x</code>。

			<blockquote>
				<p>Negative lookbehind assertion: Matches "x"
					only if "x" is not preceded by "y". </p>
			</blockquote>
		</li>
	</ol>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/(?&lt;!h)o(?!t)/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;hot&#39;</span>) <span class="syntax-all syntax-comment">// true // 除了 hot 的 o 不匹配，其他的 o 都匹配
</span><span class="syntax-all syntax-string">/(?&lt;!h)o(?!t)/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;dog&#39;</span>) <span class="syntax-all syntax-comment">// true 
</span></code></pre>

	<p>记法小窍门：把 <strong>=</strong> 替换成 <strong>!</strong> 就可以了。</p>

	<hr />

	<p>你还可以有这种操作，比如匹配位于单词中间，开头或者是末尾的字符（串），涉及到的两个操作符分别是 <code>\b</code> 和
		<code>\B</code>，</p>

	<p><code>\b</code>。一般用来匹配单词的开头或者末尾的字符（串），<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions">定义如下</a>，
	</p>

	<blockquote>
		<p>Matches a word boundary. This is the position where a word
			character is not followed or preceded by another
			word-character, such as between a letter and a space.
			Note that a matched word boundary is not included in the
			match. In other words, the length of a matched word
			boundary is zero.</p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\bmoo/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;moon&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/oon\b/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;oon&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/moo\b/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;moon&#39;</span>) <span class="syntax-all syntax-comment">// false
</span><span class="syntax-all syntax-string">/moon\b/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;mooncake&#39;</span>) <span class="syntax-all syntax-comment">// false
</span></code></pre>

	<p>其实看下名字就比较好理解了，<strong>word
			boundary</strong>，如何决定一个单词的边界呢？我们把单词用一个最小的长方形框起来，那么左边和右边的边框就是
		<strong>word boundary</strong> 了。</p>

	<p><code>\B</code>。一般用来匹配单词里的字符（串），<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions">定义如下</a>，
	</p>

	<blockquote>
		<p>Matches a non-word boundary. This is a position where the
			previous and next character are of the same type: Either
			both must be words, or both must be non-words, for
			example between two letters or between two spaces. The
			beginning and end of a string are considered non-words.
			Same as the matched word boundary, the matched non-word
			boundary is also not included in the match. </p>
	</blockquote>

	<p>这里有一点也要注意下， <strong> The beginning and end of a string are considered
			non-words</strong>，要熟悉游戏规则！！！</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\B /</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;  &#39;</span>) <span class="syntax-all syntax-comment">// true 
</span><span class="syntax-all syntax-string">/\B/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39; &#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/\B/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/moo\B/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;moon&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>

	<p>到此精确匹配一个字符的讲解就结束了。</p>

	<h3> String</h3>

	<p>到此，您应该已经是 character matching master
		了。有了上面的基础，匹配字符串就好说了，字符串，顾名思义，就是一串字符。</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/aaa/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;aaa&#39;</span>) <span class="syntax-all syntax-comment">//true
</span><span class="syntax-all syntax-string">/abc/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;abc&#39;</span>) <span class="syntax-all syntax-comment">//true
</span><span class="syntax-all syntax-string">/aaaaaaaaaa/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;aaaaaaaaaa&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>

	<p>我们匹配 3 个 <strong>a</strong>，10 个 <strong>a</strong>，这种有规律的字符串，我们可以使用
		<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Quantifiers">量词</a>
		操作符，它是字符串中最常用的操作符了，比如上面的操作我们可以用 <code>x{n}</code>
		操作符来实现，<strong>n</strong> 必须是正整数，先来看下定义，</p>

	<blockquote>
		<p>Where "n" is a positive integer, matches exactly "n"
			occurrences of the preceding item "x". </p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/a{3}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;aaa&#39;</span>) <span class="syntax-all syntax-comment">//true
</span><span class="syntax-all syntax-string">/a{10}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;aaaaaaaaaa&#39;</span>) <span class="syntax-all syntax-comment">//true
</span><span class="syntax-all syntax-string">/a{4}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;aaa&#39;</span>) <span class="syntax-all syntax-comment">//false
</span><span class="syntax-all syntax-string">/a{0}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;aaa&#39;</span>) <span class="syntax-all syntax-comment">// always true // n 必须是正整数
</span></code></pre>

	<p>那 <strong>abc</strong> 呢？也有规律，都是字母啊，我们可以用 <strong>character
			class</strong>，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/[abc]{3}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;abc&#39;</span>) <span class="syntax-all syntax-comment">//true
</span><span class="syntax-all syntax-string">/[abc]{3}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;aac&#39;</span>) <span class="syntax-all syntax-comment">//true
</span></code></pre>

	<p>这里要注意下，上面量词定义里面提到的 <strong>item</strong>，它不单单可以指某一特定字符，比如
		<strong>a</strong>，也可以指一类字符，比如，<code>[abc]</code> 这样，来看下来自 MDN
		对于量词定义中出现的 <strong>item</strong> 的注解，</p>

	<blockquote>
		<p>Note: In the following, item refers not only to singular
			characters, but also includes character classes, Unicode
			property escapes, groups and ranges.</p>
	</blockquote>

	<p>上面只是匹配 3 次，我们也可以给个区间，比如匹配 3-5 次都 OK，可以使用 <code>x{n,m}</code>
		操作符，定义如下，</p>

	<blockquote>
		<p>Where "n" is 0 or a positive integer, "m" is a positive
			integer, and m > n, matches at least "n" and at most "m"
			occurrences of the preceding item "x". </p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/a{1,5}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;&#39;</span>) <span class="syntax-all syntax-comment">//false
</span><span class="syntax-all syntax-string">/a{0,5}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;&#39;</span>) <span class="syntax-all syntax-comment">//true
</span></code></pre>

	<p>当然你也可以用 <code>x{n,}</code> 来缺省最大可匹配次数，表示至少需要匹配 <strong>n</strong>
		次，最多匹配多少次都可以，但是要求 <strong>n</strong> 是正整数，来看下定义，</p>

	<blockquote>
		<p>Where "n" is a positive integer, matches at least "n"
			occurrences of the preceding item "x".</p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/a{1,}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;&#39;</span>) <span class="syntax-all syntax-comment">// false
</span><span class="syntax-all syntax-string">/a{1,}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;a&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/a{0,}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;a&#39;</span>) <span class="syntax-all syntax-comment">// always true // n 必须是正整数
</span></code></pre>

	<p><code>x+</code> 和 上面的 <code>{1,}</code> 操作符效果一样，来看下定义，</p>

	<blockquote>
		<p>Matches the preceding item "x" 1 or more times. Equivalent to
			{1,}. </p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/a+/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;&#39;</span>) <span class="syntax-all syntax-comment">// false
</span><span class="syntax-all syntax-string">/a+/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;a&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>

	<p><code>x*</code> 操作符可以解决上面 <code>{n,m}</code> 操作符缺省 <strong>m</strong>
		时，<strong>n</strong> 等于 <strong>0</strong> 会导致结果不正确的问题，虽然你可以理解为
		<code>{0,}</code>，但是 <code>{0,}</code> 这个表达式是无效的，来看下定义，</p>

	<blockquote>
		<p>Matches the preceding item "x" 0 or more times.</p>
	</blockquote>

	<p><code>x?</code> 这个操作符在 <code>x*</code> 的基础上定义了一个最大值
		<strong>1</strong>，虽然你可以理解为 <code>{0,1}</code>，但是
		<code>{0,1}</code> 这个表达式是无效的，来看下定义，</p>

	<blockquote>
		<p>Matches the preceding item "x" 0 or 1 times. For example,
			/e?le?/ matches the "el" in "angel" and the "le" in
			"angle."</p>
	</blockquote>

	<p>等下 ！！！</p>

	<p><code>x?</code> 这个操作符还有一个特别的用途，对，就是让前面讲到的 <strong>4</strong> 种量词操作符
		<code>*</code>,<code>+</code>,<code>?</code>,<code>{}</code> 变得
		non-greedy，就是在满足情况的情况下，尽量匹配的少，来看下定义，</p>

	<blockquote>
		<p>If used immediately after any of the quantifiers *, +, ?, or
			{}, makes the quantifier non-greedy (matching the
			minimum number of times), as opposed to the default,
			which is greedy (matching the maximum number of times).
		</p>
	</blockquote>

	<p>比如，我们匹配 es6 模版字符串的话，你可能会这样写，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\$\{.+\}/</span><span class="syntax-all syntax-keyword">g.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;abc${abc}${xyz}xyz&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">&#39;abc${abc}${xyz}xyz&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\$\{.+\}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;${abc}${xyz}&#39;]
</span></code></pre>

	<p>这样看上去没问题，但是你看匹配结果你会发现它只匹配了一个模版字符串，就是 <code>${abc}${xyz}</code>
		这么一整串，因为 <code>abc}${xyz</code> 这个可以算作是模版字符串的内容啊，不是吗？正确的写法，利用
		<code>?</code> 操作符，让匹配 non-greedy，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\$\{.+?\}/</span><span class="syntax-all syntax-keyword">g.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;abc${abc}${xyz}xyz&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">&#39;abc${abc}${xyz}xyz&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\$\{.+?\}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">//&nbsp;[&#39;${abc}&#39;, &#39;${xyz}&#39;]
</span></code></pre>

	<p><code>?</code> 操作符配合其他量词操作符一共有6种组合， </p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-parameter">x</span><span class="syntax-all syntax-keyword">*?</span>
<span class="syntax-all syntax-parameter">x</span><span class="syntax-all syntax-keyword">+?</span>
<span class="syntax-all syntax-parameter">x</span><span class="syntax-all syntax-keyword">??</span>
<span class="syntax-all syntax-parameter">x</span>{<span class="syntax-all syntax-parameter">n</span>}<span class="syntax-all syntax-keyword">?</span>
<span class="syntax-all syntax-parameter">x</span>{<span class="syntax-all syntax-parameter">n</span>,}<span class="syntax-all syntax-keyword">?</span>
<span class="syntax-all syntax-parameter">x</span>{<span class="syntax-all syntax-parameter">n</span>,<span class="syntax-all syntax-parameter">m</span>}<span class="syntax-all syntax-keyword">?</span></code></pre>

	<blockquote>
		<p>By default quantifiers like * and + are "greedy", meaning
			that they try to match as much of the string as
			possible. The ? character after the quantifier makes the
			quantifier "non-greedy": meaning that it will stop as
			soon as it finds a match. </p>
	</blockquote>

	<p>来看下例子，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc*/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abccccccc&#39;]
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc*?/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;ab&#39;] // 匹配 0 个 c 
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc+/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abccccccc&#39;]
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc+?/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abc&#39;] // 匹配 1 个 c 
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc?/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abc&#39;]
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc??/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;ab&#39;] // 匹配 0 个 c 
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc{1}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abc&#39;]
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc{1}?/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abc&#39;] // 效果一样
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc{1,}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abccccccc&#39;]
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc{1,}?/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abc&#39;] // 匹配 1 个 c
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc{1,2}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abcc&#39;]
</span><span class="syntax-all syntax-string">&#39;abccccccc&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/abc{1,2}?/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;abc&#39;] // 匹配 1 个 c
</span></code></pre>

	<p>上面讲到的其实都是量词的用法，字符串里匹配字面量还有一个操作符，<code>|</code>，让你可以用一条正则来匹配两个字面量，来看下定义，
	</p>

	<blockquote>
		<p>Matches either "x" or "y". For example, /green|red/ matches
			"green" in "green apple" and "red" in "red apple".</p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/green|red/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;green&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/green|red/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;red&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>

	<p>这样看来 <code>|</code>，只能用来同时匹配多个字面量是吗，感觉用处不是很大啊，它本身是只有这个作用，但是
		！！！对又是一个但是，它和别的操作符搭配起来可以变得更强大，比如我们想匹配 <strong>hot</strong> 或者
		<strong>hat</strong>，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;hot&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/ho|at/</span><span class="syntax-all syntax-keyword">g</span>)  <span class="syntax-all syntax-comment">// [&#39;ho&#39;] 
</span><span class="syntax-all syntax-string">&#39;hot&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/hot|hat/</span><span class="syntax-all syntax-keyword">g</span>)  <span class="syntax-all syntax-comment">// [&#39;hot&#39;]
</span><span class="syntax-all syntax-string">&#39;hat&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/hot|hat/</span><span class="syntax-all syntax-keyword">g</span>)  <span class="syntax-all syntax-comment">// [&#39;hat&#39;]
</span></code></pre>

	<p>因为 <strong>hot</strong> 和 <strong>hat</strong> 只差了一个字母，而单单使用
		<code>|</code> 只能让我们匹配它左边或者右面的字符（串），有点头疼，有什么办法可以让 <code>|</code>
		附带范围效果呢？比如，让 <code>|</code> 只匹配左边一个字符和右边一个字符，这样我们匹配
		<strong>hot</strong> 或者 <strong>hat</strong> 就可以写成一开始的这样了
		<code>&#39;hot&#39;.match(/ho|at/g)</code> ，</p>

	<p>我们如果只匹配单个字符，那么我们可以用 <code>[xyz]</code> 操作符，将 <strong>o</strong> 和
		<strong>a</strong> 归属到一个 character class 里面去，这样能达到预期效果，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;hot&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/h[o|a]t/</span><span class="syntax-all syntax-keyword">g</span>)  <span class="syntax-all syntax-comment">// [&#39;hot&#39;] 
</span></code></pre>

	<p>但是这还是不能满足我们的需求，这个时候就需要 <code>(x)</code>
		操作符登场了，它能让你只匹配括号里面的东西，这样我们不就限制了匹配范围了吗？来看下定义，</p>

	<blockquote>
		<p>Capturing group: Matches x and remembers the match. For
			example, /(foo)/ matches and remembers "foo" in "foo
			bar". </p>
	</blockquote>

	<blockquote>
		<p>A regular expression may have multiple capturing groups. In
			results, matches to capturing groups typically in an
			array whose members are in the same order as the left
			parentheses in the capturing group. This is usually just
			the order of the capturing groups themselves. This
			becomes important when capturing groups are nested.
			Matches are accessed using the index of the result's
			elements ([1], ..., [n]) or from the predefined RegExp
			object's properties ($1, ..., $9).</p>
	</blockquote>

	<blockquote>
		<p>Capturing groups have a performance penalty. If you don't
			need the matched substring to be recalled, prefer
			non-capturing parentheses (see below).</p>
	</blockquote>

	<blockquote>
		<p>String.match() won't return groups if the /.../g flag is set.
			However, you can still use String.matchAll() to get all
			matches.</p>
	</blockquote>

	<p>这样我们如果想将边界限制为 <code>|</code>
		的左边一个字符，右边一个字符，我们就可以用括号将左边一个字符加<code>|</code>加右边一个字符括起来，这样就限制了范围，感觉有点像
		CSS 里面的 <strong>overflow</strong> 的效果，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;hot&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/h(o|a)t/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;hot&#39;]
</span><span class="syntax-all syntax-string">&#39;bloody&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/bloo(dy|d)/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;bloody&#39;]
</span><span class="syntax-all syntax-string">&#39;blood&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/bloo(dy|d)/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;blood&#39;]
</span></code></pre>

	<p>上面我们只是用到了 <code>(x)</code> 的一种用法，<strong>match</strong>，它还有
		<strong>remember</strong> 的作用，来我们重新看下定义，</p>

	<blockquote>
		<p>Capturing group: Matches x and remembers the match. For
			example, /(foo)/ matches and remembers "foo" in "foo
			bar". </p>
	</blockquote>

	<p><code>(x)</code> 虽然可以记住匹配了什么，但我们还需要一种机制来引用它记住的值，JavaScript
		里面的一些和正则表达式配套的函数可以提供一种机制让你引用它记住的值，就拿
		<code>String.prototype.replace()</code> <a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter">函数</a>来说，它接受两个参数，当
		<strong> replace</strong>
		函数第一个入参为正则表达式的时候，如果第二个入参是一个函数的话，那么这个函数会默认接收到几个入参，包括
		<code>(x)</code> 操作符记住的值的入参，让你可以引用它记住的字符（串），看下例子，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">function</span> <span class="syntax-all syntax-entity">replacer</span>(<span class="syntax-all syntax-parameter">match</span>, <span class="syntax-all syntax-parameter">p1</span>, <span class="syntax-all syntax-parameter">p2</span>, <span class="syntax-all syntax-parameter">p3</span>, <span class="syntax-all syntax-parameter">offset</span>, <span class="syntax-all syntax-parameter">string</span>, <span class="syntax-all syntax-parameter">groups</span>) {
  <span class="syntax-all syntax-keyword">return</span> [<span class="syntax-all syntax-parameter">p1</span>, <span class="syntax-all syntax-parameter">p2</span>, <span class="syntax-all syntax-parameter">p3</span>]<span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">join</span>(<span class="syntax-all syntax-string">&#39; - &#39;</span>);
}
<span class="syntax-all syntax-keyword">let</span> <span class="syntax-all syntax-parameter">newString</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&#39;abc12345#$*%&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">replace</span>(<span class="syntax-all syntax-string">/([^\d]*)(\d*)([^\w]*)/</span>, <span class="syntax-all syntax-parameter">replacer</span>);
<span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">newString</span>);  <span class="syntax-all syntax-comment">// abc - 12345 - #$*%
</span></code></pre>

	<p>因为我们使用了 <code>(x)</code> 操作符，所以，我们就可以用 <strong>p1</strong> 引用
		<code>([^\d]*)</code> 匹配到的字符串，用 <strong>p2</strong> 引用
		<code>(\d*)</code> 匹配到的字符串，以此类推，p1，p2，p3 的参数数量是由我们使用了多少个
		<code>(x)</code> 操作符决定的。当然这个函数还有一些其他的参数供我们使用，比如第一个参数表示 match
		到的字符串等。</p>

	<p>关于 <strong>remember</strong>/<strong>capture</strong> 的用法的话，上面我们是通过
		replacer
		函数给的入参，比如，<strong>p1</strong>，<strong>p2</strong>，<strong>p3</strong>
		等参数来引用 <code>(x)</code> 记住的值，要是我们需要引用一个值在很后面，比如我们写了 10 个
		<code>(x)</code>，然后我们碰巧需要第一个记住的值
		<strong>p10</strong>，那么我们函数的入参不是要写的很长很长了吗，像这样，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">function</span> <span class="syntax-all syntax-entity">replacer</span>(<span class="syntax-all syntax-parameter">match</span>, <span class="syntax-all syntax-parameter">p1</span>, <span class="syntax-all syntax-parameter">p2</span>, <span class="syntax-all syntax-parameter">p3</span>, <span class="syntax-all syntax-parameter">p4</span>, <span class="syntax-all syntax-parameter">p5</span>, <span class="syntax-all syntax-parameter">p6</span>, <span class="syntax-all syntax-parameter">p7</span>, <span class="syntax-all syntax-parameter">p8</span>, <span class="syntax-all syntax-parameter">p9</span>, <span class="syntax-all syntax-parameter">p10</span>, <span class="syntax-all syntax-parameter">offset</span>, <span class="syntax-all syntax-parameter">string</span>, <span class="syntax-all syntax-parameter">groups</span>) {}</code></pre>

	<p>所以正则表达式还提供了一种方式让你直接引用到 <strong>p10</strong> 的值，就是 <strong> Named
			capturing group</strong>，<code>(?&lt;Name&gt;x)</code>。
	</p>

	<p>之前，我们如果需要引用捕获（captured/remembered）的值的话，你得通过
		<code>p1</code>,<code>p2</code>… 按序号来引用，现在，你还可以直接通过名字来引用，来看下定义，
	</p>

	<blockquote>
		<p>Named capturing group: Matches "x" and stores it on the
			groups property of the returned matches under the name
			specified by <Name>. The angle brackets (< and>) are
					required for group name.</p>
	</blockquote>

	<p>之前的例子可以改写成，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">function</span> <span class="syntax-all syntax-entity">replacer</span>(<span class="syntax-all syntax-parameter">match</span>, <span class="syntax-all syntax-parameter">p1</span>, <span class="syntax-all syntax-parameter">offset</span>, <span class="syntax-all syntax-parameter">string</span>, <span class="syntax-all syntax-parameter">groups</span>) {
  <span class="syntax-all syntax-keyword">return</span> <span class="syntax-all syntax-parameter">groups</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">area</span>;
}
<span class="syntax-all syntax-keyword">let</span> <span class="syntax-all syntax-parameter">areaCode</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-string">&#39;(205)&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">replace</span>(<span class="syntax-all syntax-string">/\((?&lt;area&gt;\d\d\d)\)/</span>, <span class="syntax-all syntax-parameter">replacer</span>);
<span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">areaCode</span>);  <span class="syntax-all syntax-comment">// 205
</span></code></pre>

	<p>当然除了 JavaScript
		提供的配套函数可以让我们引用捕获的值，我们还可以直接在<strong>正则表达式</strong>里面引用我们捕获的值，高级
		！！！</p>

	<p>要在正则里面引用捕获的值，需要用到 <code>\n</code> 操作符，用来引用第 <strong>n</strong> 个
		capturing group 捕获/记住的值，<a
			href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges">定义如下</a>，
	</p>

	<blockquote>
		<p>Where "n" is a positive integer. A back reference to the last
			substring matching the n parenthetical in the regular
			expression (counting left parentheses). For example,
			/apple(,)\sorange\1/ matches "apple, orange," in "apple,
			orange, cherry, peach".</p>
	</blockquote>

	<p>举个例子，比如我们用一个正则表达式同时匹配，<strong>1</strong>，<strong>22</strong>，<strong>333</strong>，<strong>4444</strong>，这4组字符串，怎么做呢？观察下可以发现，其实就是第一个数字重复了几遍，我们自然而然就会想到
		<code>{n,m}</code> 量词操作符，试一下，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;1&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\d{1,}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;1&#39;]
</span><span class="syntax-all syntax-string">&#39;22&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\d{1,}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;22&#39;]
</span><span class="syntax-all syntax-string">&#39;333&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\d{1,}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;333&#39;]
</span><span class="syntax-all syntax-string">&#39;4444&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\d{1,}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;4444&#39;]
</span></code></pre>

	<p>完美！！！</p>

	<p>但是这个也可以匹配上 ！！！ Not something that we wanted…</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;1234&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/\d{1,}/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;1234&#39;]
</span></code></pre>

	<p>我们需要固定第一位数字，后面重复的都是刚才固定的那个数字，这个时候，就轮到我们的 <code>\n</code> 操作符出场了，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;4444&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/(\d)\1*/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;4444&#39;]
</span><span class="syntax-all syntax-string">&#39;1234&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/(\d)\1*/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;] not [&#39;1234&#39;]
</span></code></pre>

	<p><code>(\d)</code> 会匹配一个数字，然后 <code>\1</code> 表示 <code>(\d)</code>
		匹配到的字符（串），这样我们有了一个确定的字符（串）后，这样配合量词使用就可以达到我们想要的效果了，完美！！！</p>

	<p>上面的引用其实就是
		<strong>p1</strong>，<strong>p2</strong>，<strong>p3</strong>… 这种
		index 引用，配合 <strong> capturing group</strong>，对于过长的
		index，引用起来就比较麻烦了。这里我们可以使用 <strong> named capturing
			group</strong>，但是我们还需要一个操作符，配合着一起食用，这个操作符就是
		<code>\k&lt;Name&gt;</code>，来看下定义，</p>

	<blockquote>
		<p>A back reference to the last substring matching the Named
			capture group specified by <Name>.</p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;4444&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/(?&lt;number&gt;\d)\k&lt;number&gt;*/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;4444&#39;]
</span><span class="syntax-all syntax-string">&#39;22&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/(?&lt;number&gt;\d)\k&lt;number&gt;*/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;22&#39;]
</span><span class="syntax-all syntax-string">&#39;12&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/(?&lt;number&gt;\d)\k&lt;number&gt;*/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;1&#39;,&#39;2&#39;]
</span></code></pre>

	<p>Nice ！！！</p>

	<p>还记得最初的时候，我们因为给 <code>|</code> 添加范围限制的时候，使用了 <code>(x)</code> 操作符吗，因为
		<code>(x)</code>
		操作符的捕获/记住功能会有性能问题，而且那时候我们也不需要捕获功能，我们只需要范围限制功能（match）功能就行了，所以为了提升性能，我们可以使用
		<code>(?:x)</code> 操作符，只匹配，不捕获，来看下定义，</p>

	<blockquote>
		<p>Non-capturing group: Matches "x" but does not remember the
			match. The matched substring cannot be recalled from the
			resulting array's elements ([1], ..., [n]) or from the
			predefined RegExp object's properties ($1, ..., $9).</p>
	</blockquote>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;hot&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/h(?:o|a)t/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;hot&#39;]
</span><span class="syntax-all syntax-string">&#39;bloody&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/bloo(?:dy|d)/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;bloody&#39;]
</span><span class="syntax-all syntax-string">&#39;blood&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/bloo(?:dy|d)/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;blood&#39;]
</span></code></pre>

	<h3>Flag</h3>

	<p>在上面正则的学习过程中，我们已经遇到了两个 <strong>flag</strong>，<strong>u</strong> 和
		<strong>g</strong>。flag 在使用上吗没有顺序之分，比如 <code>/a/gu</code> 和
		<code>/a/ug</code> 作用是完全一样的。</p>

	<p>flag 的用法如下，</p>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">var</span> <span class="syntax-all syntax-parameter">re</span> <span class="syntax-all syntax-keyword">=</span><span class="syntax-all syntax-string"> /pattern/</span><span class="syntax-all syntax-parameter">flags</span>;</code></pre>

	<p>这里再重新学习下，</p>

	<ol>
		<li><strong>g</strong>。正常什么 flag 都不加，只会让我们匹配到第一个匹配的值。但是加了
			<strong>g</strong> flag 的话，会让我们匹配到所有的值。

			<blockquote>
				<p>Global search.</p>
			</blockquote>
		</li>
	</ol>

	<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">&#39;hackers&amp;painters&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/a/</span>) <span class="syntax-all syntax-comment">// [&#39;a&#39;, index: 1, input: &#39;hackers&amp;painters&#39;, groups: undefined]
</span><span class="syntax-all syntax-string">&#39;hackers&amp;painters&#39;</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/a/</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;a&#39;, &#39;a&#39;]
</span></code></pre>

	<ol start="2">
		<li><strong>u</strong>。 匹配 unicode code point 的时候一定要带上的 flag，不然
			<code>\u{hhhh}</code> 就没有匹配 unicode 的作用了，因为感觉不加
			<strong>u</strong> flag 的话，会和 <code>{n,m}</code>
			操作符冲突不是吗？

			<p>来温故下 <code>\u{hhhh}</code> 的定义，</p>

			<blockquote>
				<p>(Only when the u flag is set.) Matches the
					character with the Unicode value U+hhhh
					or U+hhhhh (hexadecimal digits).</p>
			</blockquote>

			<p>再来看下 <strong>u</strong> flag 的定义，</p>

			<blockquote>
				<p>&quot;unicode&quot;; treat a pattern as a
					sequence of unicode code points.</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/\u{0041}/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;A&#39;</span>)  <span class="syntax-all syntax-comment">// true
</span></code></pre>
		</li>
	</ol>

	<p>下面来学习下新的 flag，</p>

	<ol>
		<li><strong>i</strong>。Case-insensitive 的 <strong>i</strong>。

			<p>我们在搜索的时候，比如用 <code>String.prototype.match</code>
				函数，可以进行大小写不敏感的搜索，就可以利用 <code>i</code> 这个
				flag，来看下它的定义，</p>

			<blockquote>
				<p>Case-insensitive search.</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/[abc]/</span><span class="syntax-all syntax-keyword">i.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;A&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/[abc]/</span><span class="syntax-all syntax-keyword">i.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;a&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>
		</li>
		<li><strong>m</strong>。多行匹配。定义如下，

			<blockquote>
				<p>Multi-line search.</p>
			</blockquote>

			<p>虽然我们使用 <strong>g</strong>
				也可以在多行中对字符进行匹配，但是，<strong>g</strong>
				匹配的时候会算作单行进行匹配，如，</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/^football/</span><span class="syntax-all syntax-keyword">g.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">`rugby</span>

<span class="syntax-all syntax-string">football`</span>) <span class="syntax-all syntax-comment">// false
</span></code></pre>

			<p>明明 football 确实是第三行的句子开头，但是匹配不到，使用 <strong>m</strong>
				flag 就可以解决这个问题，</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-string">/^football/</span><span class="syntax-all syntax-keyword">gm.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">`rugby</span>
<span class="syntax-all syntax-string">	</span>
<span class="syntax-all syntax-string">football`</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/football/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;rugby</span><span class="syntax-all syntax-escape">\n</span><span class="syntax-all syntax-string">football&#39;</span>) <span class="syntax-all syntax-comment">// true
</span><span class="syntax-all syntax-string">/^football/</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;rugby</span><span class="syntax-all syntax-escape">\n</span><span class="syntax-all syntax-string">football&#39;</span>) <span class="syntax-all syntax-comment">// false
</span><span class="syntax-all syntax-string">/^football/</span><span class="syntax-all syntax-keyword">m.</span><span class="syntax-all syntax-variable">test</span>(<span class="syntax-all syntax-string">&#39;rugby</span><span class="syntax-all syntax-escape">\n</span><span class="syntax-all syntax-string">football&#39;</span>) <span class="syntax-all syntax-comment">// true
</span></code></pre>
		</li>
		<li><strong>s</strong>。

			<p>还记得 <code>.</code> 操作符吗，它除了 <strong>line
					terminators</strong>
				不会匹配，其他所有的字符都可以匹配，而，<code>s</code>
				flag，可以让它，真正的匹配所有的字符，定义如下，</p>

			<blockquote>
				<p>Allows . to match newline characters.</p>
			</blockquote>

			<pre><code class="code-highlighted code-js">(<span class="syntax-all syntax-string">&#39;a</span><span class="syntax-all syntax-escape">\b</span><span class="syntax-all syntax-string">&#39;</span>)<span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/./</span><span class="syntax-all syntax-keyword">g</span>) <span class="syntax-all syntax-comment">// [&#39;a&#39;, &#39;b&#39;] // 没有 \n 换行符 line terminators
</span>(<span class="syntax-all syntax-string">&#39;a</span><span class="syntax-all syntax-escape">\n</span><span class="syntax-all syntax-string">b&#39;</span>)<span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">match</span>(<span class="syntax-all syntax-string">/./</span><span class="syntax-all syntax-parameter">sg</span>) <span class="syntax-all syntax-comment">// [&#39;a&#39;, &#39;\n&#39;, &#39;b&#39;]
</span></code></pre>
		</li>
		<li><strong>y</strong>。

			<p>我们还可以指定从哪开始搜索，<strong> g</strong> 和 <strong>
					y</strong> flag 都有这个作用，配合
				<code>RegExp.prototype.lastIndex</code>
				这个属性，但是两者还是略微有点不同，先来看下 <strong>g</strong> flag
				好了，每次匹配都是从上一个匹配的字符串的末尾字符的后一个字符所对应的 index 作为起点，
			</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">var</span> <span class="syntax-all syntax-parameter">re</span> <span class="syntax-all syntax-keyword">=</span><span class="syntax-all syntax-string"> /hot|dog/</span><span class="syntax-all syntax-keyword">g</span>;
<span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 0
</span><span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">exec</span>(<span class="syntax-all syntax-string">&#39;hotdoghot&#39;</span>); 
<span class="syntax-all syntax-comment">// [&#39;hot&#39;, index: 0, input: &#39;hotdoghot&#39;, groups: undefined]
</span><span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 3
</span><span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">exec</span>(<span class="syntax-all syntax-string">&#39;hotdoghot&#39;</span>);
<span class="syntax-all syntax-comment">// [&#39;dog&#39;, index: 3, input: &#39;hotdoghot&#39;, groups: undefined]
</span><span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 6
</span><span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">exec</span>(<span class="syntax-all syntax-string">&#39;hotdoghot&#39;</span>);
<span class="syntax-all syntax-comment">// [&#39;hot&#39;, index: 6, input: &#39;hotdoghot&#39;, groups: undefined]
</span><span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 9
</span><span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">exec</span>(<span class="syntax-all syntax-string">&#39;hotdoghot&#39;</span>); <span class="syntax-all syntax-comment">// null
</span><span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 0
</span></code></pre>

			<p>我们可以通过改变 <code>RegExp.prototype.lastIndex</code> <a
					href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex">这个值</a>来修改匹配开始的位置，
			</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">var</span> <span class="syntax-all syntax-parameter">re</span> <span class="syntax-all syntax-keyword">=</span><span class="syntax-all syntax-string"> /hot|dog/</span><span class="syntax-all syntax-keyword">g</span>;
<span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 0
</span><span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">1</span>;
<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">exec</span>(<span class="syntax-all syntax-string">&#39;hotdoghot&#39;</span>); 
<span class="syntax-all syntax-comment">// 因为 lastIndex 设置为了 1， 所以相当于在匹配 &#39;otdoghot&#39;，所以第一次匹配会匹配到 dog
</span><span class="syntax-all syntax-comment">// [&#39;dog&#39;, index: 3, input: &#39;hotdoghot&#39;, groups: undefined]
</span><span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 6
</span></code></pre>

			<p>而 <strong> y</strong> flag，要求你给的 <strong>
					lastIndex</strong>
				必须是下次匹配的字符串的第一个字符在字符串中的 index ，是前一个字符的 index
				都不行，所以第一次跑下面的代码是啥都匹配不到的，</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">var</span> <span class="syntax-all syntax-parameter">re</span> <span class="syntax-all syntax-keyword">=</span><span class="syntax-all syntax-string"> /hot|dog/</span><span class="syntax-all syntax-keyword">y</span>;
<span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 0
</span><span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">1</span>;
<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">exec</span>(<span class="syntax-all syntax-string">&#39;hotdoghot&#39;</span>); <span class="syntax-all syntax-comment">// null
</span><span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 0 // 因为匹配不到所以被重置为 0 
</span></code></pre>

			<p>只有当你的 <strong> lastIndex</strong>
				是下次匹配的字符串的首字符的开头的字符的 index 才可以，</p>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">var</span> <span class="syntax-all syntax-parameter">re</span> <span class="syntax-all syntax-keyword">=</span><span class="syntax-all syntax-string"> /hot|dog/</span><span class="syntax-all syntax-keyword">y</span>;
<span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 0
</span><span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span> <span class="syntax-all syntax-keyword">=</span> <span class="syntax-all syntax-constant">3</span>;
<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">exec</span>(<span class="syntax-all syntax-string">&#39;hotdoghot&#39;</span>); <span class="syntax-all syntax-comment">// [&#39;dog&#39;, index: 3, input: &#39;hotdoghot&#39;, groups: undefined]
</span><span class="syntax-all syntax-constant">console</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-constant">log</span>(<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">lastIndex</span>); <span class="syntax-all syntax-comment">// 6
</span></code></pre>

			<p>实操好了，现在再来看下 <strong>y</strong> flag 的 定义，</p>

			<blockquote>
				<p>Perform a &quot;sticky&quot; search that
					matches starting at the current position
					in the target string. See <a
						href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky">sticky</a>.
				</p>
			</blockquote>
		</li>
		<li><strong>d</strong> flag。最后一个 flag，可以用来查看匹配到字符（串） 的开始和结束的字符的
			index，<a
				href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">定义如下</a>，

			<blockquote>
				<p>Generate indices for substring matches.</p>
			</blockquote>

			<pre><code class="code-highlighted code-js"><span class="syntax-all syntax-keyword">var</span> <span class="syntax-all syntax-parameter">re</span> <span class="syntax-all syntax-keyword">=</span><span class="syntax-all syntax-string"> /dog/</span><span class="syntax-all syntax-parameter">d</span>;
<span class="syntax-all syntax-parameter">re</span><span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-variable">exec</span>(<span class="syntax-all syntax-string">&#39;hotdoghot&#39;</span>)<span class="syntax-all syntax-keyword">.</span><span class="syntax-all syntax-parameter">indices</span>[<span class="syntax-all syntax-constant">0</span>]; <span class="syntax-all syntax-comment">// [3, 6]
</span></code></pre>
		</li>
	</ol>

	<p>到此所有的正则表达式的语法都介绍完了~</p>

	<p>恭喜你可以挺到这边~</p>

	<p>Thank for Reading~ 🎉</p>

	<hr />

	<p>但是会使用 regex 仅仅只是第一步，理解背后的算法也是很重要的，比如如何用 JavaScript 实现写一个 captruing
		group 函数呢？</p>

	<h2>参考</h2>

	<ol>
		<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">Regular
				Expressions Guide - MDN</a></li>
		<li><a href="https://unicode.org/faq/utf_bom.html#gen0">unicode.org</a>
		</li>
		<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">Javascript
				string - MDN</a></li>
	</ol>

</body>

</html>