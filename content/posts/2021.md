---
title: Regex 101
date: "2017-08-19T22:40:32.169Z"
template: "post"
draft: false
slug: "humane-typography-in-the-digital-age"
category: "Typography"
tags:
  - "Design"
  - "Typography"
  - "Web Development"
description: "An Essay on Typography by Eric Gill takes the reader back to the year 1930. The year when a conflict between two worlds came to its term. The machines of the industrial world finally took over the handicrafts."
socialImage: "/media/42-line-bible.jpg"
---

# 2021.09.01 Regular Expression 101

**Reg**ular **Exp**ression ç®€ç§° regex or regexpã€‚æ ¹æ®åŒ¹é…çš„ç²¾å‡†åº¦å¯ä»¥å°† regex åˆ†ä¸º**æ¨¡ç³ŠåŒ¹é…**å’Œ**ç²¾ç¡®åŒ¹é…**ã€‚

## æ¨¡ç³ŠåŒ¹é…

### Literals

**a** å°±æ˜¯ **a**ï¼Œ**b** å°±æ˜¯ **b**ã€‚

```js
/b/.test("abc"); // true
```

è¿˜æœ‰ä¸€ç§æ–¹å¼å¯ä»¥è¡¨ç¤º[Literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)ï¼Œå°±æ˜¯ unicode code pointï¼Œæ ¹æ®èŒƒå›´ä¸ä¸€æ ·å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ 3 ç§ï¼Œ

1. `\xhh`ã€‚

   > Matches the character with the code hh (two hexadecimal digits).

   åŒ¹é… unicode code point åœ¨ U+0000 å’Œ U+00FF (the Basic Latin and Latin-1 Supplement blocks; equivalent to ISO-8859-1) ä¹‹é—´çš„å­—ç¬¦ã€‚

   ```js
   /\x41/.test("A");
   ```

2. `\uhhhh`ã€‚

   > Matches a UTF-16 code-unit with the value hhhh (four hexadecimal digits).

   å°±æ˜¯åŒ¹é… unicode code point åœ¨ U+0000 å’Œ U+FFFF (the Unicode Basic Multilingual Plane) ä¹‹é—´çš„å­—ç¬¦ã€‚

   ```js
   /\u0041/.test('A') // true
   /\u1f926/.test('ğŸ¤¦') // åªæ”¯æŒå››ä½æ•°
   ```

3. `\u{hhhhh}`å’Œ `\u{hhhh}`ã€‚

   > (Only when the u flag is set.) Matches the character with the Unicode value U+hhhh or U+hhhhh (hexadecimal digits).

   `\u{hhhh}` çš„è¯ï¼Œæ•ˆæœå’Œ `\uhhhh` ä¸€æ ·ã€‚
   `/\u{hhhhh}/` çš„è¯ï¼ŒåŒ¹é… unicode code point åœ¨åš U+0000 å’Œ U+10FFFF (the entirety of Unicode)ä¹‹é—´çš„å­—ç¬¦ã€‚

   ```js
   /\u{0041}/u.test('A') // true
   /\u{0041}/.test('A') // false
   /\u{1f926}/u.test('ğŸ¤¦') // true
   ```

`\u{hhhhh}` å’Œ `\u{hhhh}` æ“ä½œç¬¦è¦æ³¨æ„ä¸€ç‚¹ï¼Œéœ€è¦å¸¦ä¸Š **Â u** flagï¼Œä¸ç„¶ä¼šå’Œ `x{n}` æ“ä½œç¬¦æœ‰æ­§ä¹‰ï¼Œ`x{n}` é‡è¯æ“ä½œç¬¦åé¢ä¼šè®²è§£ã€‚

å…³äºæ›´å¤šçš„ unicode çš„çŸ¥è¯†ç‚¹ï¼Œå°†åœ¨å¦ä¸€ç¯‡åšå®¢ä¸­è¿›è¡Œè¯¦ç»†è®²è§£ï¼Œæœ¬æ–‡ä¸åšèµ˜è¿°ã€‚

### Special character

**.Â ** ä¸æ˜¯ **.Â **ï¼Œ**?** ä¸æ˜¯ **?**ã€‚

```js
/?/.test('?') // Uncaught SyntaxError: Invalid regular expression: /?/: Nothing to repeat
/./.test('.') // true // è™½ç„¶æ˜¯ trueï¼Œä½†æ˜¯ä½ è¦çŸ¥é“ï¼Œ/./ è¡¨ç¤ºåŒ¹é…æ‰€æœ‰çš„å­—ç¬¦é™¤äº† line terminatorsï¼Œæ‰€ä»¥æ‰åŒ¹é…ä¸Šçš„
```

ä¸€äº›å­—ç¬¦åœ¨ regex ä¸­å…·æœ‰ç‰¹æ®Šæ„ä¹‰ã€‚å°±æ¯”å¦‚æˆ‘ä»¬ä¸Šé¢ä¾‹å­é‡Œ `/./` çš„ **.**ï¼Œæ¥çœ‹ä¸‹å®ƒçš„[å®šä¹‰](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)ï¼Œ

> Has one of the following meanings:
>
> - Matches any single character except line terminators: \n, \r, \u2028 or \u2029. For example, /.y/ matches "my" and "ay", but not "yes", in "yes make my day".
> - Inside a character class, the dot loses its special meaning and matches a literal dot.
>   Note that the m multiline flag doesn't change the dot behavior. So to match a pattern across multiple lines, the character class [^] can be used â€” it will match any character including newlines.
>   ES2018 added the s "dotAll" flag, which allows the dot to also match line terminators.

å¦‚æœä½ æƒ³è®© **.** å˜æˆæ™®é€šçš„å­—ç¬¦ï¼Œé‚£ä¹ˆä½ åªèƒ½é€šè¿‡ `\` æ“ä½œç¬¦æ¥å¯¹è¿™ä¸ªå­—ç¬¦è¿›è¡Œè½¬ä¹‰ï¼Œä½†æ˜¯ **.** æ“ä½œç¬¦æœ‰ç‚¹ç‰¹æ®Šï¼Œæ ¹æ®å®šä¹‰ä½ è¿˜å¯ä»¥ä½¿ç”¨ `[xyz]` æ“ä½œç¬¦å°† **.** å˜æˆå­—é¢é‡ï¼ˆliteralï¼‰ï¼Œä¹Ÿå°±æ˜¯æ™®é€šå­—ç¬¦ã€‚

é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸‹ `\` çš„[å®šä¹‰](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)ï¼Œ

> Indicates that the following character should be treated specially, or "escaped". It behaves one of two ways.
>
> - For characters that are usually treated literally, indicates that the next character is special and not to be interpreted literally. For example, /b/ matches the character "b". By placing a backslash in front of "b", that is by using /\b/, the character becomes special to mean match a word boundary.
> - For characters that are usually treated specially, indicates that the next character is not special and should be interpreted literally. For example, "_" is a special character that means 0 or more occurrences of the preceding character should be matched; for example, /a_/ means match 0 or more "a"s. To match _ literally, precede it with a backslash; for example, /a\*/ matches "a_".
>   Note: To match this character literally, escape it with itself. In other words to search for \ use /\\/.

è¿™é‡Œå› ä¸º **.** æ˜¯ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡ `\` æ¥è¿›è¡Œè½¬ä¹‰ä»¥å–æ¶ˆå®ƒçš„ç‰¹æ®Šæ€§ï¼Œ

```js
/./.test('1.1') // always true
/\./.test('1.1') // true // right way
/\./.test('11') // false
```

åªæ˜¯å› ä¸º **.** æ¯”è¾ƒç‰¹æ®Šï¼Œæ‰€ä»¥ä½ é€šè¿‡ `[xyz]` æ“ä½œç¬¦æ¥å°†å®ƒå˜æˆå­—é¢é‡ï¼Œæ¥çœ‹ä¸‹ `[xyz]` æ“ä½œç¬¦çš„[å®šä¹‰](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges)ï¼Œ

> A character class. Matches any one of the enclosed characters. You can specify a range of characters by using a hyphen, but if the hyphen appears as the first or last character enclosed in the square brackets it is taken as a literal hyphen to be included in the character class as a normal character.
> For example, [abcd] is the same as [a-d]. They match the "b" in "brisket", and the "c" in "chop".
> For example, [abcd-] and [-abcd] match the "b" in "brisket", the "c" in "chop", and the "-" (hyphen) in "non-profit".
> For example, [\w-] is the same as [A-Za-z0-9_-]. They both match the "b" in "brisket", the "c" in "chop", and the "n" in "non-profit".

```js
/[.]/.test('1.1') // true // right way
/[.]/.test('11') // false
```

**A character class** é¡¾åæ€ä¹‰å°±æ˜¯ä¸€ç±»å­—ç¬¦ï¼Œå¦‚ä¸‹é¢çš„ `[123]`ï¼Œåªè¦ä½ çš„å­—ç¬¦ä¸²é‡Œæœ‰ 1 æˆ–è€… 2 æˆ–è€… 3ï¼Œä¸è¦æ±‚ä½ çš„å­—ç¬¦ä¸²ä¸€å®šç­‰äº **123**ï¼Œåªè¦åŒ¹é…ä¸Šä¸€ä¸ªå­—ç¬¦å°±ç®—åŒ¹é…äº†ï¼Œ**ä¸€ç±»å­—ç¬¦**è¯´ç™½äº†è¿˜æ˜¯åŒ¹é…ä¸€ä¸ªå­—ç¬¦ï¼Œ

```js
/[123]/.test("11"); // true
```

### Not Match a character

æˆ‘ä»¬æœ‰æƒ³ä¸Šç­çš„æ—¶å€™ï¼Œå°±ä¼šæœ‰ä¸æƒ³ä¸Šç­çš„æ—¶å€™ï¼ŒåŒ¹é…ä¹Ÿæ˜¯ä¸€æ ·ã€‚ä»€ä¹ˆï¼Ÿä½ æƒ³ä¸Šç­ï¼Ÿä¸Šé¢æˆ‘ä»¬æåˆ°äº†æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `[xyz]` æ“ä½œç¬¦æ¥åŒ¹é…æŸä¸€ç±»å­—ç¬¦ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ `[^xyz]` æ¥ä¸åŒ¹é…æŸä¸€ç±»å­—ç¬¦ï¼Œè®©æˆ‘ä»¬æ¥çœ‹ä¸‹å®ƒçš„[å®šä¹‰](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges)ï¼Œ

> A negated or complemented character class. That is, it matches anything that is not enclosed in the brackets. You can specify a range of characters by using a hyphen, but if the hyphen appears as the first or last character enclosed in the square brackets it is taken as a literal hyphen to be included in the character class as a normal character. For example, [^abc] is the same as [^a-c]. They initially match "o" in "bacon" and "h" in "chop".
> Note: The ^ character may also indicate the beginning of input.

æ„æ€å°±æ˜¯ï¼Œåªè¦æˆ‘ä»¬çš„å­—ç¬¦ä¸²é‡Œæœ‰ä¸€ä¸ªå­—ç¬¦ä¸åœ¨è¿™ä¸€ç±»å­—ç¬¦é‡Œé¢ï¼Œé‚£ä¹ˆå°±è¡¨ç¤ºä¸åŒ¹é…æˆåŠŸäº†ï¼Œ

```js
/[^xyz]/.test('xab') // true // a å’Œ b ä¸å±äº xyz é‡Œé¢
/[^xyz]/.test('xyz') // false // xyz å’Œ xyz ç›¸ç­‰
```

### Character class

ä¸€ç±»å­—ç¬¦ã€‚ä¸Šé¢æˆ‘ä»¬æåˆ°äº† `[xyz]` æ“ä½œç¬¦å¯ä»¥å®šä¹‰ä¸€ç±»å­—ç¬¦ç”¨æ¥åŒ¹é…ï¼Œæ¯”å¦‚æˆ‘ä»¬æƒ³åŒ¹é…é˜¿æ‹‰ä¼¯æ•°å­—ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼Œ`[0123456789]` æˆ–è€… `[0-9]`ï¼Œ

```js
/[0123456789]/.test('t3st') // true
/[0-9]/.test('t3st') // true
/[0123456789]/.test('test') // false
```

è¿™ä¹ˆå¸¸ç”¨çš„æ“ä½œï¼Œæ­£å­—è¡¨è¾¾å¼é‡Œæœ‰è¯­æ³•ç³–å—ï¼Ÿè¿˜çœŸæœ‰ï¼Œå®ƒå†…ç½®äº†ä¸€äº› character classï¼Œæ¯”å¦‚ä¸Šé¢çš„ `[0-9]` æˆ–è€… `[0123456789]` å¯ä»¥ç”¨ `\d` æ¥ä»£æ›¿ï¼Œ å…¶[å®šä¹‰](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)å¦‚ä¸‹ï¼š

> Matches any digit (Arabic numeral). Equivalent to [0-9]. For example, /\d/ or /[0-9]/ matches "2" in "B2 is the suite number".

d å°±æ˜¯ digit çš„æ„æ€ã€‚

```js
/\d/.test("t3st"); // true
```

`/[^0-9]/`ï¼Œé‚£ä¹ˆä¸åŒ¹é…é˜¿æ‹‰ä¼¯æ•°å­—å‘¢ï¼Ÿä¹Ÿæœ‰å¯¹åº”çš„è¯­æ³•ç³–ï¼Œ`\D`ï¼Œå’Œ `\d` å¯¹åº”ï¼Œæ­£å¥½æ˜¯å¤§å°å†™å…³ç³»ï¼Œå®šä¹‰å¦‚ä¸‹ï¼Œ

> Matches any character that is not a digit (Arabic numeral). Equivalent to [^0-9]. For example, /\D/ or /[^0-9]/ matches "B" in "B2 is the suite number".

```js
/\D/.test('test') // true
/\D/.test('123') // false
```

---

é™¤äº†ä¸Šé¢è¿™ä¸¤ä¸ª character class å…¶ä»–çš„ character class ä¹Ÿéå¸¸å®ç”¨ï¼Œ

1. `\w`ã€‚åŒ¹é… 24 ä¸ªå­—æ¯å’Œæ•°å­—å¤–åŠ ä¸€ä¸ªä¸‹åˆ’çº¿ã€‚

   > Matches any alphanumeric character from the basic Latin alphabet, including the underscore. Equivalent to [A-Za-z0-9_]. For example, /\w/ matches "a" in "apple", "5" in "$5.28", "3" in "3D" and "m" in "Ã‰manuel".

   ```js
   "abc def".match(/\w/g); // ['a', 'b', 'c', 'd', 'e', 'f'] // æ²¡æœ‰åŒ¹é…ç©ºæ ¼
   ```

   ä¸Šé¢çš„ `/\w/g` é‡Œé¢çš„ **g** çš„æ„æ€æ˜¯åŒ¹é…æ‰€æœ‰å­—ç¬¦ï¼Œè¿™ä¸ªåé¢ä¼šè®²è§£ï¼Œç°åœ¨åªéœ€è¦ç†è§£ä¸‹æ„æ€å°±è¡Œã€‚

2. `\W`ã€‚ä¸åŒ¹é… 24 ä¸ªå­—æ¯å’Œæ•°å­—å¤–åŠ ä¸€ä¸ªä¸‹åˆ’çº¿ã€‚

   > Matches any character that is not a word character from the basic Latin alphabet. Equivalent to [^a-za-z0-9_]. For example, /\W/ or /[^a-za-z0-9_]/ matches "%" in "50%" and "Ã‰" in "Ã‰manuel".

   ```js
   "abc def".match(/\W/g); // [' '] // åŒ¹é…äº†ä¸ªç©ºæ ¼
   ```

3. `\s`ã€‚åŒ¹é…ä¸€ä¸ªç©ºæ ¼å­—ç¬¦(white space character)ã€‚

   > Matches a single white space character, including space, tab, form feed, line feed, and other Unicode spaces. Equivalent to [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]. For example, /\s\w\*/ matches " bar" in "foo bar".

   ```js
   "abc def".match(/\s/g); // [' '] // å•å•åªåŒ¹é…ç©ºæ ¼å­—ç¬¦
   ```

4. `\S`ã€‚ä¸åŒ¹é…ä¸€ä¸ªç©ºæ ¼å­—ç¬¦(white space character)ã€‚

   > Matches a single character other than white space. Equivalent to [^ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]. For example, /\S\w\*/ matches "foo" in "foo bar".

   ```js
   "abc def".match(/\S/g); // ['a', 'b', 'c', 'd', 'e', 'f'] // é™¤äº†ç©ºæ ¼å­—ç¬¦ï¼Œå…¶ä»–éƒ½åŒ¹é…
   ```

5. ç©ºæ ¼å­—ç¬¦(white space character)ã€‚

   ```js
   \t: Matches a horizontal tab.
   \r: Matches a carriage return.
   \n: Matches a linefeed.
   \v: Matches a vertical tab.
   \f: Matches a form-feed.
   ```

   ```js
   /\n/.test('\n') // true
   /\r/.test('\r') // true
   /\t/.test('\t') // true
   /\v/.test('\v') // true
   /\f/.test('\f') // true
   ```

   è¿˜è®°å¾—ä¹‹å‰æåˆ°çš„ `\` æ“ä½œç¬¦å—ï¼Œå®ƒå¯ä»¥å°†ç‰¹æ®Šå­—ç¬¦è½¬ç§»æˆæ™®é€šå­—ç¬¦ï¼Œä¹Ÿå¯ä»¥å°†æ™®é€šå­—ç¬¦è½¬ç§»æˆç‰¹æ®Šå­—ç¬¦ï¼Œæ¯”å¦‚ï¼Œ**r**ï¼Œæ²¡æœ‰ä»»ä½•ç‰¹æ®Šå«ä¹‰ï¼Œé‚£ä¹ˆè½¬ä¹‰ä¸‹å®ƒï¼Œ `\r`ï¼Œå®ƒå°±è¡¨ç¤ºå›è½¦å­—ç¬¦äº†ã€‚ è¿˜æœ‰ `\` æœ¬èº«æ˜¯ç‰¹æ®Šå­—ç¬¦ï¼Œå¦‚æœä½ æƒ³åŒ¹é…å®ƒæœ¬èº«çš„è¯ï¼Œé‚£ä¹ˆå°±å¾—è½¬ä¹‰å®ƒè‡ªå·±ï¼Œ`\\`ï¼Œ

   ```js
   /\\/.test('\\') // true
   /\\r/.test('\\r') // true
   ```

6. `\p{UnicodeProperty}`ã€‚å¯ä»¥ç®—ä½œä¹‹å‰çš„ `uhhhh` ç­‰çš„ character classï¼ŒåŒ¹é…ä¸€ç±» unicodeï¼Œæ¯”å¦‚åŒ¹é…è¡¨æƒ…ï¼Œ

   ```js
   const sentence = "A ticket to å¤§é˜ª costs Â¥2000 ğŸ‘Œ.";
   const regexpEmojiPresentation = /\p{Emoji_Presentation}/gu;
   console.log(sentence.match(regexpEmojiPresentation));
   // expected output: Array ["ğŸ‘Œ"]
   ```

   > Matches a character based on its [Unicode character properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes) (to match just, for example, emoji characters, or Japanese katakana characters, or Chinese/Japanese Han/Kanji characters, etc.).

   è¯¦ç»†çš„å®šä¹‰å¦‚ä¸‹ï¼Œ

   > Unicode property escapes Regular Expressions allows for matching characters based on their Unicode properties. A character is described by several properties which are either binary ("boolean-like") or non-binary. For instance, unicode property escapes can be used to match emojis, punctuations, letters (even letters from specific languages or scripts), etc.

   ç”¨æ³•å®šä¹‰å¦‚ä¸‹ï¼Œ

   ```js
   // Non-binary values
   \p{UnicodePropertyValue}
   \p{UnicodePropertyName=UnicodePropertyValue}

   // Binary and non-binary values
   \p{UnicodeBinaryPropertyName}

   // Negation: \P is negated \p
   \P{UnicodePropertyValue}
   \P{UnicodeBinaryPropertyName}
   ```

   è¯¦ç»†ä»‹ç»è¯·å‚è€ƒï¼Œ[Unicode property escapes - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes)ã€‚

7. `[\b]`ã€‚**b** è¿™ä¸ªå­—ç¬¦å’Œ **.** å­—ç¬¦æ¯”è¾ƒç‰¹æ®Šï¼Œå®ƒä»¬ä¿©åœ¨ `[xyz]` æ“ä½œç¬¦ä¸­è¡¨ç¤ºå­—é¢é‡ï¼Œä¸è¿‡ä¹Ÿä¸å¸¸ç”¨ï¼Œå®šä¹‰å¦‚ä¸‹ã€‚

   > Matches a backspace. If you're looking for the word-boundary character (\b), see Assertions.

   ```js
   /[\b]/.test('\x08') // true
   /[\b]/.test('\b') // true
   ```

8. `\0`ã€‚ ä¸å¸¸ç”¨ã€‚

   > Matches a NUL character. Do not follow this with another digit.

   ```js
   /[\0]/.test("\0"); // true
   ```

9. `\cX`ã€‚ä¸å¸¸ç”¨ã€‚

   > Matches a control character using [caret notation], where "X" is a letter from Aâ€“Z (corresponding to codepoints U+0001â€“U+001A). For example, /\cM\cJ/ matches "\r\n".

   ```js
   "\r\n".match(/\cM\cJ/g); // ['\r\n']
   ```

åˆ°æ­¤æ¨¡ç³ŠåŒ¹é…çš„æ•™ç¨‹å°±ç»“æŸäº†ã€‚

## ç²¾ç¡®åŒ¹é…

æ ¹æ®ç›®æ ‡å­—ç¬¦ä¸²åŠ ä¸Šé¢å¤–çš„åŒ¹é…æ¡ä»¶æ¥ç²¾ç¡®åŒ¹é…ç›®æ ‡å­—ç¬¦ã€‚æ¯”å¦‚æˆ‘æƒ³åŒ¹é… **hot** çš„ **o**ï¼Œè€Œä¸æ˜¯ **dog** çš„ **o**ï¼Œæˆ‘ä»¬å°±éœ€è¦ç”¨ **o** å­—ç¬¦å‰åçš„å­—ç¬¦ï¼ˆä¸²ï¼‰ä½œä¸ºé¢å¤–çš„åŒ¹é…æ¡ä»¶æ¥è¿›è¡Œç²¾ç¡®åŒ¹é…ã€‚

```js
/(?<=h)o(?=t)/.test('hot') // true // ä¸“é—¨ç”¨æ¥åŒ¹é… hot
/(?<=h)o(?=t)/.test('dog') // false
```

ä¸Šé¢æˆ‘ä»¬ç”¨åˆ°äº† `x(?=y)` å’Œ `(?<=y)x` è¿™ä¸¤ä¸ª [æ–­è¨€](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions)ï¼ˆassertionsï¼‰æ“ä½œç¬¦ï¼Œæ¥çœ‹ä¸‹å®ƒä»¬çš„å®šä¹‰ï¼Œ

1. `x(?=y)`ã€‚ç”¨ç›®æ ‡å­—ç¬¦ **x** åé¢çš„å­—ç¬¦ï¼ˆä¸²ï¼‰ä½œä¸ºé¢å¤–åŒ¹é…æ¡ä»¶ï¼Œ

   > Lookahead assertion: Matches "x" only if "x" is followed by "y".

2. `(?<=y)x`ã€‚ç”¨ç›®æ ‡å­—ç¬¦ **x** å‰é¢çš„å­—ç¬¦ï¼ˆä¸²ï¼‰ä½œä¸ºé¢å¤–åŒ¹é…æ¡ä»¶ï¼Œ

   > Lookbehind assertion: Matches "x" only if "x" is preceded by "y".

   ä½†æ˜¯çœ‹ä¸Šå»åœ¨å†™è¿™ç¯‡æ–‡ç« çš„æ—¶å€™ï¼Œ safari è¿˜ä¸æ”¯æŒè¿™ä¸ª `(negative) lookbehind assertion`æ“ä½œç¬¦ï¼Œä¼šæŠ¥é”™ï¼Œ

   ```js
   /(?<!h)o/.test("hot"); // SyntaxError: Invalid regular expression: invalid group specifier name
   ```

è®°æ³•å°çªé—¨ï¼š`(?<=y)x` æ“ä½œç¬¦é‡Œæœ‰ä¸€ä¸ª **Â \<** ç¬¦å·ï¼Œä½ å°†å®ƒç†è§£ä¸ºå‘å·¦çœ‹å°±å¾ˆå¥½æäº†ã€‚

ä¸Šé¢è¯´çš„éƒ½æ˜¯ç­‰äºçš„æƒ…å†µï¼Œå½“ä½ ä¸æƒ³åŒ¹é…æŸä¸€ä¸ªæ¡ä»¶çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨ `x(?!y)` å’Œ `(?<!y)x` æ“ä½œç¬¦ï¼Œ

1. `x(?!y)`ã€‚

   > Negative lookahead assertion: Matches "x" only if "x" is not followed by "y".

2. `(?<!y)x`ã€‚

   > Negative lookbehind assertion: Matches "x" only if "x" is not preceded by "y".

```js
/(?<!h)o(?!t)/.test('hot') // true // é™¤äº† hot çš„ o ä¸åŒ¹é…ï¼Œå…¶ä»–çš„ o éƒ½åŒ¹é…
/(?<!h)o(?!t)/.test('dog') // true
```

è®°æ³•å°çªé—¨ï¼šæŠŠ **=** æ›¿æ¢æˆ **!** å°±å¯ä»¥äº†ã€‚

---

ä½ è¿˜å¯ä»¥æœ‰è¿™ç§æ“ä½œï¼Œæ¯”å¦‚åŒ¹é…ä½äºå•è¯ä¸­é—´ï¼Œå¼€å¤´æˆ–è€…æ˜¯æœ«å°¾çš„å­—ç¬¦ï¼ˆä¸²ï¼‰ï¼Œæ¶‰åŠåˆ°çš„ä¸¤ä¸ªæ“ä½œç¬¦åˆ†åˆ«æ˜¯ `\b` å’Œ `\B`ï¼Œ

`\b`ã€‚ä¸€èˆ¬ç”¨æ¥åŒ¹é…å•è¯çš„å¼€å¤´æˆ–è€…æœ«å°¾çš„å­—ç¬¦ï¼ˆä¸²ï¼‰ï¼Œ[å®šä¹‰å¦‚ä¸‹](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions)ï¼Œ

> Matches a word boundary. This is the position where a word character is not followed or preceded by another word-character, such as between a letter and a space. Note that a matched word boundary is not included in the match. In other words, the length of a matched word boundary is zero.

```js
/\bmoo/.test('moon') // true
/oon\b/.test('oon') // true
/moo\b/.test('moon') // false
/moon\b/.test('mooncake') // false
```

å…¶å®çœ‹ä¸‹åå­—å°±æ¯”è¾ƒå¥½ç†è§£äº†ï¼Œ**word boundary**ï¼Œå¦‚ä½•å†³å®šä¸€ä¸ªå•è¯çš„è¾¹ç•Œå‘¢ï¼Ÿæˆ‘ä»¬æŠŠå•è¯ç”¨ä¸€ä¸ªæœ€å°çš„é•¿æ–¹å½¢æ¡†èµ·æ¥ï¼Œé‚£ä¹ˆå·¦è¾¹å’Œå³è¾¹çš„è¾¹æ¡†å°±æ˜¯ **word boundary** äº†ã€‚

`\B`ã€‚ä¸€èˆ¬ç”¨æ¥åŒ¹é…å•è¯é‡Œçš„å­—ç¬¦ï¼ˆä¸²ï¼‰ï¼Œ[å®šä¹‰å¦‚ä¸‹](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions)ï¼Œ

> Matches a non-word boundary. This is a position where the previous and next character are of the same type: Either both must be words, or both must be non-words, for example between two letters or between two spaces. The beginning and end of a string are considered non-words. Same as the matched word boundary, the matched non-word boundary is also not included in the match.

è¿™é‡Œæœ‰ä¸€ç‚¹ä¹Ÿè¦æ³¨æ„ä¸‹ï¼Œ **Â The beginning and end of a string are considered non-words**ï¼Œè¦ç†Ÿæ‚‰æ¸¸æˆè§„åˆ™ï¼ï¼ï¼

```js
/\B /.test('  ') // true
/\B/.test(' ') // true
/\B/.test('') // true
/moo\B/.test('moon') // true
```

åˆ°æ­¤ç²¾ç¡®åŒ¹é…ä¸€ä¸ªå­—ç¬¦çš„è®²è§£å°±ç»“æŸäº†ã€‚

### String

åˆ°æ­¤ï¼Œæ‚¨åº”è¯¥å·²ç»æ˜¯ character matching master äº†ã€‚æœ‰äº†ä¸Šé¢çš„åŸºç¡€ï¼ŒåŒ¹é…å­—ç¬¦ä¸²å°±å¥½è¯´äº†ï¼Œå­—ç¬¦ä¸²ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯ä¸€ä¸²å­—ç¬¦ã€‚

```js
/aaa/.test('aaa') //true
/abc/.test('abc') //true
/aaaaaaaaaa/.test('aaaaaaaaaa') // true
```

æˆ‘ä»¬åŒ¹é… 3 ä¸ª **a**ï¼Œ10 ä¸ª **a**ï¼Œè¿™ç§æœ‰è§„å¾‹çš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ [é‡è¯](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Quantifiers) æ“ä½œç¬¦ï¼Œå®ƒæ˜¯å­—ç¬¦ä¸²ä¸­æœ€å¸¸ç”¨çš„æ“ä½œç¬¦äº†ï¼Œæ¯”å¦‚ä¸Šé¢çš„æ“ä½œæˆ‘ä»¬å¯ä»¥ç”¨ `x{n}` æ“ä½œç¬¦æ¥å®ç°ï¼Œ**n** å¿…é¡»æ˜¯æ­£æ•´æ•°ï¼Œå…ˆæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> Where "n" is a positive integer, matches exactly "n" occurrences of the preceding item "x".

```js
/a{3}/.test('aaa') //true
/a{10}/.test('aaaaaaaaaa') //true
/a{4}/.test('aaa') //false
/a{0}/.test('aaa') // always true // n å¿…é¡»æ˜¯æ­£æ•´æ•°
```

é‚£ **abc** å‘¢ï¼Ÿä¹Ÿæœ‰è§„å¾‹ï¼Œéƒ½æ˜¯å­—æ¯å•Šï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ **character class**ï¼Œ

```js
/[abc]{3}/.test('abc') //true
/[abc]{3}/.test('aac') //true
```

è¿™é‡Œè¦æ³¨æ„ä¸‹ï¼Œä¸Šé¢é‡è¯å®šä¹‰é‡Œé¢æåˆ°çš„ **item**ï¼Œå®ƒä¸å•å•å¯ä»¥æŒ‡æŸä¸€ç‰¹å®šå­—ç¬¦ï¼Œæ¯”å¦‚ **a**ï¼Œä¹Ÿå¯ä»¥æŒ‡ä¸€ç±»å­—ç¬¦ï¼Œæ¯”å¦‚ï¼Œ`[abc]` è¿™æ ·ï¼Œæ¥çœ‹ä¸‹æ¥è‡ª MDN å¯¹äºé‡è¯å®šä¹‰ä¸­å‡ºç°çš„ **item** çš„æ³¨è§£ï¼Œ

> Note: In the following, item refers not only to singular characters, but also includes character classes, Unicode property escapes, groups and ranges.

ä¸Šé¢åªæ˜¯åŒ¹é… 3 æ¬¡ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç»™ä¸ªåŒºé—´ï¼Œæ¯”å¦‚åŒ¹é… 3-5 æ¬¡éƒ½ OKï¼Œå¯ä»¥ä½¿ç”¨ `x{n,m}` æ“ä½œç¬¦ï¼Œå®šä¹‰å¦‚ä¸‹ï¼Œ

> Where "n" is 0 or a positive integer, "m" is a positive integer, and m > n, matches at least "n" and at most "m" occurrences of the preceding item "x".

```js
/a{1,5}/.test('') //false
/a{0,5}/.test('') //true
```

å½“ç„¶ä½ ä¹Ÿå¯ä»¥ç”¨ `x{n,}` æ¥ç¼ºçœæœ€å¤§å¯åŒ¹é…æ¬¡æ•°ï¼Œè¡¨ç¤ºè‡³å°‘éœ€è¦åŒ¹é… **n** æ¬¡ï¼Œæœ€å¤šåŒ¹é…å¤šå°‘æ¬¡éƒ½å¯ä»¥ï¼Œä½†æ˜¯è¦æ±‚ **n** æ˜¯æ­£æ•´æ•°ï¼Œæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> Where "n" is a positive integer, matches at least "n" occurrences of the preceding item "x".

```js
/a{1,}/.test('') // false
/a{1,}/.test('a') // true
/a{0,}/.test('a') // always true // n å¿…é¡»æ˜¯æ­£æ•´æ•°
```

`x+` å’Œ ä¸Šé¢çš„ `{1,}` æ“ä½œç¬¦æ•ˆæœä¸€æ ·ï¼Œæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> Matches the preceding item "x" 1 or more times. Equivalent to {1,}.

```js
/a+/.test("") / // false
  a +
  /.test('a') / / true;
```

`x*` æ“ä½œç¬¦å¯ä»¥è§£å†³ä¸Šé¢ `{n,m}` æ“ä½œç¬¦ç¼ºçœ **m** æ—¶ï¼Œ**n** ç­‰äº **0** ä¼šå¯¼è‡´ç»“æœä¸æ­£ç¡®çš„é—®é¢˜ï¼Œè™½ç„¶ä½ å¯ä»¥ç†è§£ä¸º `{0,}`ï¼Œä½†æ˜¯ `{0,}` è¿™ä¸ªè¡¨è¾¾å¼æ˜¯æ— æ•ˆçš„ï¼Œæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> Matches the preceding item "x" 0 or more times.

`x?` è¿™ä¸ªæ“ä½œç¬¦åœ¨ `x*` çš„åŸºç¡€ä¸Šå®šä¹‰äº†ä¸€ä¸ªæœ€å¤§å€¼ **1**ï¼Œè™½ç„¶ä½ å¯ä»¥ç†è§£ä¸º `{0,1}`ï¼Œä½†æ˜¯ `{0,1}` è¿™ä¸ªè¡¨è¾¾å¼æ˜¯æ— æ•ˆçš„ï¼Œæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> Matches the preceding item "x" 0 or 1 times. For example, /e?le?/ matches the "el" in "angel" and the "le" in "angle."

ç­‰ä¸‹ ï¼ï¼ï¼

`x?` è¿™ä¸ªæ“ä½œç¬¦è¿˜æœ‰ä¸€ä¸ªç‰¹åˆ«çš„ç”¨é€”ï¼Œå¯¹ï¼Œå°±æ˜¯è®©å‰é¢è®²åˆ°çš„ **4** ç§é‡è¯æ“ä½œç¬¦ `*`,`+`,`?`,`{}` å˜å¾— non-greedyï¼Œå°±æ˜¯åœ¨æ»¡è¶³æƒ…å†µçš„æƒ…å†µä¸‹ï¼Œå°½é‡åŒ¹é…çš„å°‘ï¼Œæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> If used immediately after any of the quantifiers \*, +, ?, or {}, makes the quantifier non-greedy (matching the minimum number of times), as opposed to the default, which is greedy (matching the maximum number of times).

æ¯”å¦‚ï¼Œæˆ‘ä»¬åŒ¹é… es6 æ¨¡ç‰ˆå­—ç¬¦ä¸²çš„è¯ï¼Œä½ å¯èƒ½ä¼šè¿™æ ·å†™ï¼Œ

```js
/\$\{.+\}/g.test("abc${abc}${xyz}xyz"); // true
"abc${abc}${xyz}xyz".match(/\$\{.+\}/g); // ['${abc}${xyz}']
```

è¿™æ ·çœ‹ä¸Šå»æ²¡é—®é¢˜ï¼Œä½†æ˜¯ä½ çœ‹åŒ¹é…ç»“æœä½ ä¼šå‘ç°å®ƒåªåŒ¹é…äº†ä¸€ä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²ï¼Œå°±æ˜¯ `${abc}${xyz}` è¿™ä¹ˆä¸€æ•´ä¸²ï¼Œå› ä¸º `abc}${xyz` è¿™ä¸ªå¯ä»¥ç®—ä½œæ˜¯æ¨¡ç‰ˆå­—ç¬¦ä¸²çš„å†…å®¹å•Šï¼Œä¸æ˜¯å—ï¼Ÿæ­£ç¡®çš„å†™æ³•ï¼Œåˆ©ç”¨ `?` æ“ä½œç¬¦ï¼Œè®©åŒ¹é… non-greedyï¼Œ

```js
/\$\{.+?\}/g.test("abc${abc}${xyz}xyz"); // true
"abc${abc}${xyz}xyz".match(/\$\{.+?\}/g); //Â ['${abc}', '${xyz}']
```

`?` æ“ä½œç¬¦é…åˆå…¶ä»–é‡è¯æ“ä½œç¬¦ä¸€å…±æœ‰ 6 ç§ç»„åˆï¼Œ

```js
x*?
x+?
x??
x{n}?
x{n,}?
x{n,m}?
```

> By default quantifiers like \* and + are "greedy", meaning that they try to match as much of the string as possible. The ? character after the quantifier makes the quantifier "non-greedy": meaning that it will stop as soon as it finds a match.

æ¥çœ‹ä¸‹ä¾‹å­ï¼Œ

```js
"abccccccc".match(/abc*/g); // ['abccccccc']
"abccccccc".match(/abc*?/g); // ['ab'] // åŒ¹é… 0 ä¸ª c
"abccccccc".match(/abc+/g); // ['abccccccc']
"abccccccc".match(/abc+?/g); // ['abc'] // åŒ¹é… 1 ä¸ª c
"abccccccc".match(/abc?/g); // ['abc']
"abccccccc".match(/abc??/g); // ['ab'] // åŒ¹é… 0 ä¸ª c
"abccccccc".match(/abc{1}/g); // ['abc']
"abccccccc".match(/abc{1}?/g); // ['abc'] // æ•ˆæœä¸€æ ·
"abccccccc".match(/abc{1,}/g); // ['abccccccc']
"abccccccc".match(/abc{1,}?/g); // ['abc'] // åŒ¹é… 1 ä¸ª c
"abccccccc".match(/abc{1,2}/g); // ['abcc']
"abccccccc".match(/abc{1,2}?/g); // ['abc'] // åŒ¹é… 1 ä¸ª c
```

ä¸Šé¢è®²åˆ°çš„å…¶å®éƒ½æ˜¯é‡è¯çš„ç”¨æ³•ï¼Œå­—ç¬¦ä¸²é‡ŒåŒ¹é…å­—é¢é‡è¿˜æœ‰ä¸€ä¸ªæ“ä½œç¬¦ï¼Œ`|`ï¼Œè®©ä½ å¯ä»¥ç”¨ä¸€æ¡æ­£åˆ™æ¥åŒ¹é…ä¸¤ä¸ªå­—é¢é‡ï¼Œæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> Matches either "x" or "y". For example, /green|red/ matches "green" in "green apple" and "red" in "red apple".

```js
/green|red/.test('green') // true
/green|red/.test('red') // true
```

è¿™æ ·çœ‹æ¥ `|`ï¼Œåªèƒ½ç”¨æ¥åŒæ—¶åŒ¹é…å¤šä¸ªå­—é¢é‡æ˜¯å—ï¼Œæ„Ÿè§‰ç”¨å¤„ä¸æ˜¯å¾ˆå¤§å•Šï¼Œå®ƒæœ¬èº«æ˜¯åªæœ‰è¿™ä¸ªä½œç”¨ï¼Œä½†æ˜¯ ï¼ï¼ï¼å¯¹åˆæ˜¯ä¸€ä¸ªä½†æ˜¯ï¼Œå®ƒå’Œåˆ«çš„æ“ä½œç¬¦æ­é…èµ·æ¥å¯ä»¥å˜å¾—æ›´å¼ºå¤§ï¼Œæ¯”å¦‚æˆ‘ä»¬æƒ³åŒ¹é… **hot** æˆ–è€… **hat**ï¼Œ

```js
"hot".match(/ho|at/g); // ['ho']
"hot".match(/hot|hat/g); // ['hot']
"hat".match(/hot|hat/g); // ['hat']
```

å› ä¸º **hot** å’Œ **hat** åªå·®äº†ä¸€ä¸ªå­—æ¯ï¼Œè€Œå•å•ä½¿ç”¨ `|` åªèƒ½è®©æˆ‘ä»¬åŒ¹é…å®ƒå·¦è¾¹æˆ–è€…å³é¢çš„å­—ç¬¦ï¼ˆä¸²ï¼‰ï¼Œæœ‰ç‚¹å¤´ç–¼ï¼Œæœ‰ä»€ä¹ˆåŠæ³•å¯ä»¥è®© `|` é™„å¸¦èŒƒå›´æ•ˆæœå‘¢ï¼Ÿæ¯”å¦‚ï¼Œè®© `|` åªåŒ¹é…å·¦è¾¹ä¸€ä¸ªå­—ç¬¦å’Œå³è¾¹ä¸€ä¸ªå­—ç¬¦ï¼Œè¿™æ ·æˆ‘ä»¬åŒ¹é… **hot** æˆ–è€… **hat** å°±å¯ä»¥å†™æˆä¸€å¼€å§‹çš„è¿™æ ·äº† `'hot'.match(/ho|at/g)` ï¼Œ

æˆ‘ä»¬å¦‚æœåªåŒ¹é…å•ä¸ªå­—ç¬¦ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç”¨ `[xyz]` æ“ä½œç¬¦ï¼Œå°† **o** å’Œ **a** å½’å±åˆ°ä¸€ä¸ª character class é‡Œé¢å»ï¼Œè¿™æ ·èƒ½è¾¾åˆ°é¢„æœŸæ•ˆæœï¼Œ

```js
"hot".match(/h[o|a]t/g); // ['hot']
```

ä½†æ˜¯è¿™è¿˜æ˜¯ä¸èƒ½æ»¡è¶³æˆ‘ä»¬çš„éœ€æ±‚ï¼Œè¿™ä¸ªæ—¶å€™å°±éœ€è¦ `(x)` æ“ä½œç¬¦ç™»åœºäº†ï¼Œå®ƒèƒ½è®©ä½ åªåŒ¹é…æ‹¬å·é‡Œé¢çš„ä¸œè¥¿ï¼Œè¿™æ ·æˆ‘ä»¬ä¸å°±é™åˆ¶äº†åŒ¹é…èŒƒå›´äº†å—ï¼Ÿæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> Capturing group: Matches x and remembers the match. For example, /(foo)/ matches and remembers "foo" in "foo bar".
> A regular expression may have multiple capturing groups. In results, matches to capturing groups typically in an array whose members are in the same order as the left parentheses in the capturing group. This is usually just the order of the capturing groups themselves. This becomes important when capturing groups are nested. Matches are accessed using the index of the result's elements ([1], ..., [n]) or from the predefined RegExp object's properties ($1, ..., $9).
> Capturing groups have a performance penalty. If you don't need the matched substring to be recalled, prefer non-capturing parentheses (see below).
> String.match() won't return groups if the /.../g flag is set. However, you can still use String.matchAll() to get all matches.

è¿™æ ·æˆ‘ä»¬å¦‚æœæƒ³å°†è¾¹ç•Œé™åˆ¶ä¸º `|` çš„å·¦è¾¹ä¸€ä¸ªå­—ç¬¦ï¼Œå³è¾¹ä¸€ä¸ªå­—ç¬¦ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç”¨æ‹¬å·å°†å·¦è¾¹ä¸€ä¸ªå­—ç¬¦åŠ `|`åŠ å³è¾¹ä¸€ä¸ªå­—ç¬¦æ‹¬èµ·æ¥ï¼Œè¿™æ ·å°±é™åˆ¶äº†èŒƒå›´ï¼Œæ„Ÿè§‰æœ‰ç‚¹åƒ CSS é‡Œé¢çš„ **overflow** çš„æ•ˆæœï¼Œ

```js
"hot".match(/h(o|a)t/g); // ['hot']
"bloody".match(/bloo(dy|d)/g); // ['bloody']
"blood".match(/bloo(dy|d)/g); // ['blood']
```

ä¸Šé¢æˆ‘ä»¬åªæ˜¯ç”¨åˆ°äº† `(x)` çš„ä¸€ç§ç”¨æ³•ï¼Œ**match**ï¼Œå®ƒè¿˜æœ‰ **remember** çš„ä½œç”¨ï¼Œæ¥æˆ‘ä»¬é‡æ–°çœ‹ä¸‹å®šä¹‰ï¼Œ

> Capturing group: Matches x and remembers the match. For example, /(foo)/ matches and remembers "foo" in "foo bar".

`(x)` è™½ç„¶å¯ä»¥è®°ä½åŒ¹é…äº†ä»€ä¹ˆï¼Œä½†æˆ‘ä»¬è¿˜éœ€è¦ä¸€ç§æœºåˆ¶æ¥å¼•ç”¨å®ƒè®°ä½çš„å€¼ï¼ŒJavaScript é‡Œé¢çš„ä¸€äº›å’Œæ­£åˆ™è¡¨è¾¾å¼é…å¥—çš„å‡½æ•°å¯ä»¥æä¾›ä¸€ç§æœºåˆ¶è®©ä½ å¼•ç”¨å®ƒè®°ä½çš„å€¼ï¼Œå°±æ‹¿ `String.prototype.replace()` [å‡½æ•°](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter)æ¥è¯´ï¼Œå®ƒæ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œå½“ **Â replace** å‡½æ•°ç¬¬ä¸€ä¸ªå…¥å‚ä¸ºæ­£åˆ™è¡¨è¾¾å¼çš„æ—¶å€™ï¼Œå¦‚æœç¬¬äºŒä¸ªå…¥å‚æ˜¯ä¸€ä¸ªå‡½æ•°çš„è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªå‡½æ•°ä¼šé»˜è®¤æ¥æ”¶åˆ°å‡ ä¸ªå…¥å‚ï¼ŒåŒ…æ‹¬ `(x)` æ“ä½œç¬¦è®°ä½çš„å€¼çš„å…¥å‚ï¼Œè®©ä½ å¯ä»¥å¼•ç”¨å®ƒè®°ä½çš„å­—ç¬¦ï¼ˆä¸²ï¼‰ï¼Œçœ‹ä¸‹ä¾‹å­ï¼Œ

```js
function replacer(match, p1, p2, p3, offset, string, groups) {
  return [p1, p2, p3].join(" - ");
}
let newString = "abc12345#$*%".replace(/([^\d]*)(\d*)([^\w]*)/, replacer);
console.log(newString); // abc - 12345 - #$*%
```

å› ä¸ºæˆ‘ä»¬ä½¿ç”¨äº† `(x)` æ“ä½œç¬¦ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç”¨ **p1** å¼•ç”¨ `([^\d]*)` åŒ¹é…åˆ°çš„å­—ç¬¦ä¸²ï¼Œç”¨ **p2** å¼•ç”¨ `(\d*)` åŒ¹é…åˆ°çš„å­—ç¬¦ä¸²ï¼Œä»¥æ­¤ç±»æ¨ï¼Œp1ï¼Œp2ï¼Œp3 çš„å‚æ•°æ•°é‡æ˜¯ç”±æˆ‘ä»¬ä½¿ç”¨äº†å¤šå°‘ä¸ª `(x)` æ“ä½œç¬¦å†³å®šçš„ã€‚å½“ç„¶è¿™ä¸ªå‡½æ•°è¿˜æœ‰ä¸€äº›å…¶ä»–çš„å‚æ•°ä¾›æˆ‘ä»¬ä½¿ç”¨ï¼Œæ¯”å¦‚ç¬¬ä¸€ä¸ªå‚æ•°è¡¨ç¤º match åˆ°çš„å­—ç¬¦ä¸²ç­‰ã€‚

å…³äº **remember**/**capture** çš„ç”¨æ³•çš„è¯ï¼Œä¸Šé¢æˆ‘ä»¬æ˜¯é€šè¿‡ replacer å‡½æ•°ç»™çš„å…¥å‚ï¼Œæ¯”å¦‚ï¼Œ**p1**ï¼Œ**p2**ï¼Œ**p3** ç­‰å‚æ•°æ¥å¼•ç”¨ `(x)` è®°ä½çš„å€¼ï¼Œè¦æ˜¯æˆ‘ä»¬éœ€è¦å¼•ç”¨ä¸€ä¸ªå€¼åœ¨å¾ˆåé¢ï¼Œæ¯”å¦‚æˆ‘ä»¬å†™äº† 10 ä¸ª `(x)`ï¼Œç„¶åæˆ‘ä»¬ç¢°å·§éœ€è¦ç¬¬ä¸€ä¸ªè®°ä½çš„å€¼ **p10**ï¼Œé‚£ä¹ˆæˆ‘ä»¬å‡½æ•°çš„å…¥å‚ä¸æ˜¯è¦å†™çš„å¾ˆé•¿å¾ˆé•¿äº†å—ï¼Œåƒè¿™æ ·ï¼Œ

```js
function replacer(
  match,
  p1,
  p2,
  p3,
  p4,
  p5,
  p6,
  p7,
  p8,
  p9,
  p10,
  offset,
  string,
  groups
) {}
```

æ‰€ä»¥æ­£åˆ™è¡¨è¾¾å¼è¿˜æä¾›äº†ä¸€ç§æ–¹å¼è®©ä½ ç›´æ¥å¼•ç”¨åˆ° **p10** çš„å€¼ï¼Œå°±æ˜¯ **Â Named capturing group**ï¼Œ`(?<Name>x)`ã€‚

ä¹‹å‰ï¼Œæˆ‘ä»¬å¦‚æœéœ€è¦å¼•ç”¨æ•è·ï¼ˆcaptured/rememberedï¼‰çš„å€¼çš„è¯ï¼Œä½ å¾—é€šè¿‡ `p1`,`p2`â€¦ æŒ‰åºå·æ¥å¼•ç”¨ï¼Œç°åœ¨ï¼Œä½ è¿˜å¯ä»¥ç›´æ¥é€šè¿‡åå­—æ¥å¼•ç”¨ï¼Œæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> Named capturing group: Matches "x" and stores it on the groups property of the returned matches under the name specified by <Name>. The angle brackets (< and >) are required for group name.

ä¹‹å‰çš„ä¾‹å­å¯ä»¥æ”¹å†™æˆï¼Œ

```js
function replacer(match, p1, offset, string, groups) {
  return groups.area;
}
let areaCode = "(205)".replace(/\((?<area>\d\d\d)\)/, replacer);
console.log(areaCode); // 205
```

å½“ç„¶é™¤äº† JavaScript æä¾›çš„é…å¥—å‡½æ•°å¯ä»¥è®©æˆ‘ä»¬å¼•ç”¨æ•è·çš„å€¼ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç›´æ¥åœ¨**æ­£åˆ™è¡¨è¾¾å¼**é‡Œé¢å¼•ç”¨æˆ‘ä»¬æ•è·çš„å€¼ï¼Œé«˜çº§ ï¼ï¼ï¼

è¦åœ¨æ­£åˆ™é‡Œé¢å¼•ç”¨æ•è·çš„å€¼ï¼Œéœ€è¦ç”¨åˆ° `\n` æ“ä½œç¬¦ï¼Œç”¨æ¥å¼•ç”¨ç¬¬ **n** ä¸ª capturing group æ•è·/è®°ä½çš„å€¼ï¼Œ[å®šä¹‰å¦‚ä¸‹](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges)ï¼Œ

> Where "n" is a positive integer. A back reference to the last substring matching the n parenthetical in the regular expression (counting left parentheses). For example, /apple(,)\sorange\1/ matches "apple, orange," in "apple, orange, cherry, peach".

ä¸¾ä¸ªä¾‹å­ï¼Œæ¯”å¦‚æˆ‘ä»¬ç”¨ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼åŒæ—¶åŒ¹é…ï¼Œ**1**ï¼Œ**22**ï¼Œ**333**ï¼Œ**4444**ï¼Œè¿™ 4 ç»„å­—ç¬¦ä¸²ï¼Œæ€ä¹ˆåšå‘¢ï¼Ÿè§‚å¯Ÿä¸‹å¯ä»¥å‘ç°ï¼Œå…¶å®å°±æ˜¯ç¬¬ä¸€ä¸ªæ•°å­—é‡å¤äº†å‡ éï¼Œæˆ‘ä»¬è‡ªç„¶è€Œç„¶å°±ä¼šæƒ³åˆ° `{n,m}` é‡è¯æ“ä½œç¬¦ï¼Œè¯•ä¸€ä¸‹ï¼Œ

```js
"1".match(/\d{1,}/g); // ['1']
"22".match(/\d{1,}/g); // ['22']
"333".match(/\d{1,}/g); // ['333']
"4444".match(/\d{1,}/g); // ['4444']
```

å®Œç¾ï¼ï¼ï¼

ä½†æ˜¯è¿™ä¸ªä¹Ÿå¯ä»¥åŒ¹é…ä¸Š ï¼ï¼ï¼ Not something that we wantedâ€¦

```js
"1234".match(/\d{1,}/g); // ['1234']
```

æˆ‘ä»¬éœ€è¦å›ºå®šç¬¬ä¸€ä½æ•°å­—ï¼Œåé¢é‡å¤çš„éƒ½æ˜¯åˆšæ‰å›ºå®šçš„é‚£ä¸ªæ•°å­—ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œå°±è½®åˆ°æˆ‘ä»¬çš„ `\n` æ“ä½œç¬¦å‡ºåœºäº†ï¼Œ

```js
"4444".match(/(\d)\1*/g); // ['4444']
"1234".match(/(\d)\1*/g); // ['1', '2', '3', '4'] not ['1234']
```

`(\d)` ä¼šåŒ¹é…ä¸€ä¸ªæ•°å­—ï¼Œç„¶å `\1` è¡¨ç¤º `(\d)` åŒ¹é…åˆ°çš„å­—ç¬¦ï¼ˆä¸²ï¼‰ï¼Œè¿™æ ·æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªç¡®å®šçš„å­—ç¬¦ï¼ˆä¸²ï¼‰åï¼Œè¿™æ ·é…åˆé‡è¯ä½¿ç”¨å°±å¯ä»¥è¾¾åˆ°æˆ‘ä»¬æƒ³è¦çš„æ•ˆæœäº†ï¼Œå®Œç¾ï¼ï¼ï¼

ä¸Šé¢çš„å¼•ç”¨å…¶å®å°±æ˜¯ **p1**ï¼Œ**p2**ï¼Œ**p3**â€¦ è¿™ç§ index å¼•ç”¨ï¼Œé…åˆ **Â capturing group**ï¼Œå¯¹äºè¿‡é•¿çš„ indexï¼Œå¼•ç”¨èµ·æ¥å°±æ¯”è¾ƒéº»çƒ¦äº†ã€‚è¿™é‡Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ **Â named capturing group**ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªæ“ä½œç¬¦ï¼Œé…åˆç€ä¸€èµ·é£Ÿç”¨ï¼Œè¿™ä¸ªæ“ä½œç¬¦å°±æ˜¯ `\k<Name>`ï¼Œæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> A back reference to the last substring matching the Named capture group specified by <Name>.

```js
"4444".match(/(?<number>\d)\k<number>*/g); // ['4444']
"22".match(/(?<number>\d)\k<number>*/g); // ['22']
"12".match(/(?<number>\d)\k<number>*/g); // ['1','2']
```

Nice ï¼ï¼ï¼

è¿˜è®°å¾—æœ€åˆçš„æ—¶å€™ï¼Œæˆ‘ä»¬å› ä¸ºç»™ `|` æ·»åŠ èŒƒå›´é™åˆ¶çš„æ—¶å€™ï¼Œä½¿ç”¨äº† `(x)` æ“ä½œç¬¦å—ï¼Œå› ä¸º `(x)` æ“ä½œç¬¦çš„æ•è·/è®°ä½åŠŸèƒ½ä¼šæœ‰æ€§èƒ½é—®é¢˜ï¼Œè€Œä¸”é‚£æ—¶å€™æˆ‘ä»¬ä¹Ÿä¸éœ€è¦æ•è·åŠŸèƒ½ï¼Œæˆ‘ä»¬åªéœ€è¦èŒƒå›´é™åˆ¶åŠŸèƒ½ï¼ˆmatchï¼‰åŠŸèƒ½å°±è¡Œäº†ï¼Œæ‰€ä»¥ä¸ºäº†æå‡æ€§èƒ½ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `(?:x)` æ“ä½œç¬¦ï¼ŒåªåŒ¹é…ï¼Œä¸æ•è·ï¼Œæ¥çœ‹ä¸‹å®šä¹‰ï¼Œ

> Non-capturing group: Matches "x" but does not remember the match. The matched substring cannot be recalled from the resulting array's elements ([1], ..., [n]) or from the predefined RegExp object's properties ($1, ..., $9).

```js
"hot".match(/h(?:o|a)t/g); // ['hot']
"bloody".match(/bloo(?:dy|d)/g); // ['bloody']
"blood".match(/bloo(?:dy|d)/g); // ['blood']
```

### Flag

åœ¨ä¸Šé¢æ­£åˆ™çš„å­¦ä¹ è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å·²ç»é‡åˆ°äº†ä¸¤ä¸ª **flag**ï¼Œ**u** å’Œ **g**ã€‚flag åœ¨ä½¿ç”¨ä¸Šå—æ²¡æœ‰é¡ºåºä¹‹åˆ†ï¼Œæ¯”å¦‚ `/a/gu` å’Œ `/a/ug` ä½œç”¨æ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚

flag çš„ç”¨æ³•å¦‚ä¸‹ï¼Œ

```js
var re = /pattern/flags;
```

è¿™é‡Œå†é‡æ–°å­¦ä¹ ä¸‹ï¼Œ

1. **g**ã€‚æ­£å¸¸ä»€ä¹ˆ flag éƒ½ä¸åŠ ï¼Œåªä¼šè®©æˆ‘ä»¬åŒ¹é…åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…çš„å€¼ã€‚ä½†æ˜¯åŠ äº† **g** flag çš„è¯ï¼Œä¼šè®©æˆ‘ä»¬åŒ¹é…åˆ°æ‰€æœ‰çš„å€¼ã€‚

   > Global search.

```js
"hackers&painters".match(/a/); // ['a', index: 1, input: 'hackers&painters', groups: undefined]
"hackers&painters".match(/a/g); // ['a', 'a']
```

2. **u**ã€‚ åŒ¹é… unicode code point çš„æ—¶å€™ä¸€å®šè¦å¸¦ä¸Šçš„ flagï¼Œä¸ç„¶ `\u{hhhh}` å°±æ²¡æœ‰åŒ¹é… unicode çš„ä½œç”¨äº†ï¼Œå› ä¸ºæ„Ÿè§‰ä¸åŠ  **u** flag çš„è¯ï¼Œä¼šå’Œ `{n,m}` æ“ä½œç¬¦å†²çªä¸æ˜¯å—ï¼Ÿ

   æ¥æ¸©æ•…ä¸‹ `\u{hhhh}` çš„å®šä¹‰ï¼Œ

   > (Only when the u flag is set.) Matches the character with the Unicode value U+hhhh or U+hhhhh (hexadecimal digits).

   å†æ¥çœ‹ä¸‹ **u** flag çš„å®šä¹‰ï¼Œ

   > "unicode"; treat a pattern as a sequence of unicode code points.

   ```js
   /\u{0041}/.test("A"); // true
   ```

ä¸‹é¢æ¥å­¦ä¹ ä¸‹æ–°çš„ flagï¼Œ

1. **i**ã€‚Case-insensitive çš„ **i**ã€‚

   æˆ‘ä»¬åœ¨æœç´¢çš„æ—¶å€™ï¼Œæ¯”å¦‚ç”¨ `String.prototype.match` å‡½æ•°ï¼Œå¯ä»¥è¿›è¡Œå¤§å°å†™ä¸æ•æ„Ÿçš„æœç´¢ï¼Œå°±å¯ä»¥åˆ©ç”¨ `i` è¿™ä¸ª flagï¼Œæ¥çœ‹ä¸‹å®ƒçš„å®šä¹‰ï¼Œ

   > Case-insensitive search.

   ```js
   /[abc]/i.test("A") / // true
     [abc] /
     i.test("a"); // true
   ```

2. **m**ã€‚å¤šè¡ŒåŒ¹é…ã€‚å®šä¹‰å¦‚ä¸‹ï¼Œ

   > Multi-line search.

   è™½ç„¶æˆ‘ä»¬ä½¿ç”¨ **g** ä¹Ÿå¯ä»¥åœ¨å¤šè¡Œä¸­å¯¹å­—ç¬¦è¿›è¡ŒåŒ¹é…ï¼Œä½†æ˜¯ï¼Œ**g** åŒ¹é…çš„æ—¶å€™ä¼šç®—ä½œå•è¡Œè¿›è¡ŒåŒ¹é…ï¼Œå¦‚ï¼Œ

   ```js
   /^football/g.test(`rugby
   
   football`); // false
   ```

   æ˜æ˜ football ç¡®å®æ˜¯ç¬¬ä¸‰è¡Œçš„å¥å­å¼€å¤´ï¼Œä½†æ˜¯åŒ¹é…ä¸åˆ°ï¼Œä½¿ç”¨ **m** flag å°±å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œ

   ```js
   /^football/gm.test(`rugby

   football`) // true
   /football/.test('rugby\nfootball') // true
   /^football/.test('rugby\nfootball') // false
   /^football/m.test('rugby\nfootball') // true
   ```

3. **s**ã€‚

   è¿˜è®°å¾— `.` æ“ä½œç¬¦å—ï¼Œå®ƒé™¤äº† **line terminators** ä¸ä¼šåŒ¹é…ï¼Œå…¶ä»–æ‰€æœ‰çš„å­—ç¬¦éƒ½å¯ä»¥åŒ¹é…ï¼Œè€Œï¼Œ`s` flagï¼Œå¯ä»¥è®©å®ƒï¼ŒçœŸæ­£çš„åŒ¹é…æ‰€æœ‰çš„å­—ç¬¦ï¼Œå®šä¹‰å¦‚ä¸‹ï¼Œ

   > Allows . to match newline characters.

   ```js
   "a\b"
     .match(/./g)(
       // ['a', 'b'] // æ²¡æœ‰ \n æ¢è¡Œç¬¦ line terminators
       "a\nb"
     )
     .match(/./gs); // ['a', '\n', 'b']
   ```

4. **y**ã€‚

   æˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šä»å“ªå¼€å§‹æœç´¢ï¼Œ**Â g** å’Œ **Â y** flag éƒ½æœ‰è¿™ä¸ªä½œç”¨ï¼Œé…åˆ `RegExp.prototype.lastIndex` è¿™ä¸ªå±æ€§ï¼Œä½†æ˜¯ä¸¤è€…è¿˜æ˜¯ç•¥å¾®æœ‰ç‚¹ä¸åŒï¼Œå…ˆæ¥çœ‹ä¸‹ **g** flag å¥½äº†ï¼Œæ¯æ¬¡åŒ¹é…éƒ½æ˜¯ä»ä¸Šä¸€ä¸ªåŒ¹é…çš„å­—ç¬¦ä¸²çš„æœ«å°¾å­—ç¬¦çš„åä¸€ä¸ªå­—ç¬¦æ‰€å¯¹åº”çš„ index ä½œä¸ºèµ·ç‚¹ï¼Œ

   ```js
   var re = /hot|dog/g;
   console.log(re.lastIndex); // 0
   re.exec("hotdoghot");
   // ['hot', index: 0, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 3
   re.exec("hotdoghot");
   // ['dog', index: 3, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 6
   re.exec("hotdoghot");
   // ['hot', index: 6, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 9
   re.exec("hotdoghot"); // null
   console.log(re.lastIndex); // 0
   ```

   æˆ‘ä»¬å¯ä»¥é€šè¿‡æ”¹å˜ `RegExp.prototype.lastIndex` [è¿™ä¸ªå€¼](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex)æ¥ä¿®æ”¹åŒ¹é…å¼€å§‹çš„ä½ç½®ï¼Œ

   ```js
   var re = /hot|dog/g;
   console.log(re.lastIndex); // 0
   re.lastIndex = 1;
   re.exec("hotdoghot");
   // å› ä¸º lastIndex è®¾ç½®ä¸ºäº† 1ï¼Œ æ‰€ä»¥ç›¸å½“äºåœ¨åŒ¹é… 'otdoghot'ï¼Œæ‰€ä»¥ç¬¬ä¸€æ¬¡åŒ¹é…ä¼šåŒ¹é…åˆ° dog
   // ['dog', index: 3, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 6
   ```

   è€Œ **Â y** flagï¼Œè¦æ±‚ä½ ç»™çš„ **Â lastIndex** å¿…é¡»æ˜¯ä¸‹æ¬¡åŒ¹é…çš„å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­çš„ index ï¼Œæ˜¯å‰ä¸€ä¸ªå­—ç¬¦çš„ index éƒ½ä¸è¡Œï¼Œæ‰€ä»¥ç¬¬ä¸€æ¬¡è·‘ä¸‹é¢çš„ä»£ç æ˜¯å•¥éƒ½åŒ¹é…ä¸åˆ°çš„ï¼Œ

   ```js
   var re = /hot|dog/y;
   console.log(re.lastIndex); // 0
   re.lastIndex = 1;
   re.exec("hotdoghot"); // null
   console.log(re.lastIndex); // 0 // å› ä¸ºåŒ¹é…ä¸åˆ°æ‰€ä»¥è¢«é‡ç½®ä¸º 0
   ```

   åªæœ‰å½“ä½ çš„ **Â lastIndex** æ˜¯ä¸‹æ¬¡åŒ¹é…çš„å­—ç¬¦ä¸²çš„é¦–å­—ç¬¦çš„å¼€å¤´çš„å­—ç¬¦çš„ index æ‰å¯ä»¥ï¼Œ

   ```js
   var re = /hot|dog/y;
   console.log(re.lastIndex); // 0
   re.lastIndex = 3;
   re.exec("hotdoghot"); // ['dog', index: 3, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 6
   ```

   å®æ“å¥½äº†ï¼Œç°åœ¨å†æ¥çœ‹ä¸‹ **y** flag çš„ å®šä¹‰ï¼Œ

   > Perform a "sticky" search that matches starting at the current position in the target string. See [sticky](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky).

5. **d** flagã€‚æœ€åä¸€ä¸ª flagï¼Œå¯ä»¥ç”¨æ¥æŸ¥çœ‹åŒ¹é…åˆ°å­—ç¬¦ï¼ˆä¸²ï¼‰ çš„å¼€å§‹å’Œç»“æŸçš„å­—ç¬¦çš„ indexï¼Œ[å®šä¹‰å¦‚ä¸‹](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)ï¼Œ

   > Generate indices for substring matches.

   ```js
   var re = /dog/d;
   re.exec("hotdoghot").indices[0]; // [3, 6]
   ```

åˆ°æ­¤æ‰€æœ‰çš„æ­£åˆ™è¡¨è¾¾å¼çš„è¯­æ³•éƒ½ä»‹ç»å®Œäº†~

æ­å–œä½ å¯ä»¥æŒºåˆ°è¿™è¾¹~

Thank for Reading~ ğŸ‰

---

ä½†æ˜¯ä¼šä½¿ç”¨ regex ä»…ä»…åªæ˜¯ç¬¬ä¸€æ­¥ï¼Œç†è§£èƒŒåçš„ç®—æ³•ä¹Ÿæ˜¯å¾ˆé‡è¦çš„ï¼Œæ¯”å¦‚å¦‚ä½•ç”¨ JavaScript å®ç°å†™ä¸€ä¸ª captruing group å‡½æ•°å‘¢ï¼Ÿ

## å‚è€ƒ

1. [Regular Expressions Guide - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
2. [unicode.org](https://unicode.org/faq/utf_bom.html#gen0)
3. [Javascript string - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)
