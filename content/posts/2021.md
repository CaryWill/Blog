---
title: Regex 101
date: "2017-08-19T22:40:32.169Z"
template: "post"
draft: false
slug: "humane-typography-in-the-digital-age"
category: "Typography"
tags:
  - "Design"
  - "Typography"
  - "Web Development"
description: "An Essay on Typography by Eric Gill takes the reader back to the year 1930. The year when a conflict between two worlds came to its term. The machines of the industrial world finally took over the handicrafts."
socialImage: "/media/42-line-bible.jpg"
---

# 2021.09.01 Regular Expression 101

**Reg**ular **Exp**ression 简称 regex or regexp。根据匹配的精准度可以将 regex 分为**模糊匹配**和**精确匹配**。

## 模糊匹配

### Literals

**a** 就是 **a**，**b** 就是 **b**。

```js
/b/.test("abc"); // true
```

还有一种方式可以表示[Literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)，就是 unicode code point，根据范围不一样可以分为以下 3 种，

1. `\xhh`。

   > Matches the character with the code hh (two hexadecimal digits).

   匹配 unicode code point 在 U+0000 和 U+00FF (the Basic Latin and Latin-1 Supplement blocks; equivalent to ISO-8859-1) 之间的字符。

   ```js
   /\x41/.test("A");
   ```

2. `\uhhhh`。

   > Matches a UTF-16 code-unit with the value hhhh (four hexadecimal digits).

   就是匹配 unicode code point 在 U+0000 和 U+FFFF (the Unicode Basic Multilingual Plane) 之间的字符。

   ```js
   /\u0041/.test('A') // true
   /\u1f926/.test('🤦') // 只支持四位数
   ```

3. `\u{hhhhh}`和 `\u{hhhh}`。

   > (Only when the u flag is set.) Matches the character with the Unicode value U+hhhh or U+hhhhh (hexadecimal digits).

   `\u{hhhh}` 的话，效果和 `\uhhhh` 一样。
   `/\u{hhhhh}/` 的话，匹配 unicode code point 在做 U+0000 和 U+10FFFF (the entirety of Unicode)之间的字符。

   ```js
   /\u{0041}/u.test('A') // true
   /\u{0041}/.test('A') // false
   /\u{1f926}/u.test('🤦') // true
   ```

`\u{hhhhh}` 和 `\u{hhhh}` 操作符要注意一点，需要带上 ** u** flag，不然会和 `x{n}` 操作符有歧义，`x{n}` 量词操作符后面会讲解。

关于更多的 unicode 的知识点，将在另一篇博客中进行详细讲解，本文不做赘述。

### Special character

**. ** 不是 **. **，**?** 不是 **?**。

```js
/?/.test('?') // Uncaught SyntaxError: Invalid regular expression: /?/: Nothing to repeat
/./.test('.') // true // 虽然是 true，但是你要知道，/./ 表示匹配所有的字符除了 line terminators，所以才匹配上的
```

一些字符在 regex 中具有特殊意义。就比如我们上面例子里 `/./` 的 **.**，来看下它的[定义](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)，

> Has one of the following meanings:
>
> - Matches any single character except line terminators: \n, \r, \u2028 or \u2029. For example, /.y/ matches "my" and "ay", but not "yes", in "yes make my day".
> - Inside a character class, the dot loses its special meaning and matches a literal dot.
>   Note that the m multiline flag doesn't change the dot behavior. So to match a pattern across multiple lines, the character class [^] can be used — it will match any character including newlines.
>   ES2018 added the s "dotAll" flag, which allows the dot to also match line terminators.

如果你想让 **.** 变成普通的字符，那么你只能通过 `\` 操作符来对这个字符进行转义，但是 **.** 操作符有点特殊，根据定义你还可以使用 `[xyz]` 操作符将 **.** 变成字面量（literal），也就是普通字符。

首先我们来看下 `\` 的[定义](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)，

> Indicates that the following character should be treated specially, or "escaped". It behaves one of two ways.
>
> - For characters that are usually treated literally, indicates that the next character is special and not to be interpreted literally. For example, /b/ matches the character "b". By placing a backslash in front of "b", that is by using /\b/, the character becomes special to mean match a word boundary.
> - For characters that are usually treated specially, indicates that the next character is not special and should be interpreted literally. For example, "_" is a special character that means 0 or more occurrences of the preceding character should be matched; for example, /a_/ means match 0 or more "a"s. To match _ literally, precede it with a backslash; for example, /a\*/ matches "a_".
>   Note: To match this character literally, escape it with itself. In other words to search for \ use /\\/.

这里因为 **.** 是一个特殊字符，所以我们可以通过 `\` 来进行转义以取消它的特殊性，

```js
/./.test('1.1') // always true
/\./.test('1.1') // true // right way
/\./.test('11') // false
```

只是因为 **.** 比较特殊，所以你通过 `[xyz]` 操作符来将它变成字面量，来看下 `[xyz]` 操作符的[定义](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges)，

> A character class. Matches any one of the enclosed characters. You can specify a range of characters by using a hyphen, but if the hyphen appears as the first or last character enclosed in the square brackets it is taken as a literal hyphen to be included in the character class as a normal character.
> For example, [abcd] is the same as [a-d]. They match the "b" in "brisket", and the "c" in "chop".
> For example, [abcd-] and [-abcd] match the "b" in "brisket", the "c" in "chop", and the "-" (hyphen) in "non-profit".
> For example, [\w-] is the same as [A-Za-z0-9_-]. They both match the "b" in "brisket", the "c" in "chop", and the "n" in "non-profit".

```js
/[.]/.test('1.1') // true // right way
/[.]/.test('11') // false
```

**A character class** 顾名思义就是一类字符，如下面的 `[123]`，只要你的字符串里有 1 或者 2 或者 3，不要求你的字符串一定等于 **123**，只要匹配上一个字符就算匹配了，**一类字符**说白了还是匹配一个字符，

```js
/[123]/.test("11"); // true
```

### Not Match a character

我们有想上班的时候，就会有不想上班的时候，匹配也是一样。什么？你想上班？上面我们提到了我们可以使用 `[xyz]` 操作符来匹配某一类字符，也可以使用 `[^xyz]` 来不匹配某一类字符，让我们来看下它的[定义](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges)，

> A negated or complemented character class. That is, it matches anything that is not enclosed in the brackets. You can specify a range of characters by using a hyphen, but if the hyphen appears as the first or last character enclosed in the square brackets it is taken as a literal hyphen to be included in the character class as a normal character. For example, [^abc] is the same as [^a-c]. They initially match "o" in "bacon" and "h" in "chop".
> Note: The ^ character may also indicate the beginning of input.

意思就是，只要我们的字符串里有一个字符不在这一类字符里面，那么就表示不匹配成功了，

```js
/[^xyz]/.test('xab') // true // a 和 b 不属于 xyz 里面
/[^xyz]/.test('xyz') // false // xyz 和 xyz 相等
```

### Character class

一类字符。上面我们提到了 `[xyz]` 操作符可以定义一类字符用来匹配，比如我们想匹配阿拉伯数字，那么我们可以这样写，`[0123456789]` 或者 `[0-9]`，

```js
/[0123456789]/.test('t3st') // true
/[0-9]/.test('t3st') // true
/[0123456789]/.test('test') // false
```

这么常用的操作，正字表达式里有语法糖吗？还真有，它内置了一些 character class，比如上面的 `[0-9]` 或者 `[0123456789]` 可以用 `\d` 来代替， 其[定义](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)如下：

> Matches any digit (Arabic numeral). Equivalent to [0-9]. For example, /\d/ or /[0-9]/ matches "2" in "B2 is the suite number".

d 就是 digit 的意思。

```js
/\d/.test("t3st"); // true
```

`/[^0-9]/`，那么不匹配阿拉伯数字呢？也有对应的语法糖，`\D`，和 `\d` 对应，正好是大小写关系，定义如下，

> Matches any character that is not a digit (Arabic numeral). Equivalent to [^0-9]. For example, /\D/ or /[^0-9]/ matches "B" in "B2 is the suite number".

```js
/\D/.test('test') // true
/\D/.test('123') // false
```

---

除了上面这两个 character class 其他的 character class 也非常实用，

1. `\w`。匹配 24 个字母和数字外加一个下划线。

   > Matches any alphanumeric character from the basic Latin alphabet, including the underscore. Equivalent to [A-Za-z0-9_]. For example, /\w/ matches "a" in "apple", "5" in "$5.28", "3" in "3D" and "m" in "Émanuel".

   ```js
   "abc def".match(/\w/g); // ['a', 'b', 'c', 'd', 'e', 'f'] // 没有匹配空格
   ```

   上面的 `/\w/g` 里面的 **g** 的意思是匹配所有字符，这个后面会讲解，现在只需要理解下意思就行。

2. `\W`。不匹配 24 个字母和数字外加一个下划线。

   > Matches any character that is not a word character from the basic Latin alphabet. Equivalent to [^a-za-z0-9_]. For example, /\W/ or /[^a-za-z0-9_]/ matches "%" in "50%" and "É" in "Émanuel".

   ```js
   "abc def".match(/\W/g); // [' '] // 匹配了个空格
   ```

3. `\s`。匹配一个空格字符(white space character)。

   > Matches a single white space character, including space, tab, form feed, line feed, and other Unicode spaces. Equivalent to [ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]. For example, /\s\w\*/ matches " bar" in "foo bar".

   ```js
   "abc def".match(/\s/g); // [' '] // 单单只匹配空格字符
   ```

4. `\S`。不匹配一个空格字符(white space character)。

   > Matches a single character other than white space. Equivalent to [^ \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]. For example, /\S\w\*/ matches "foo" in "foo bar".

   ```js
   "abc def".match(/\S/g); // ['a', 'b', 'c', 'd', 'e', 'f'] // 除了空格字符，其他都匹配
   ```

5. 空格字符(white space character)。

   ```js
   \t: Matches a horizontal tab.
   \r: Matches a carriage return.
   \n: Matches a linefeed.
   \v: Matches a vertical tab.
   \f: Matches a form-feed.
   ```

   ```js
   /\n/.test('\n') // true
   /\r/.test('\r') // true
   /\t/.test('\t') // true
   /\v/.test('\v') // true
   /\f/.test('\f') // true
   ```

   还记得之前提到的 `\` 操作符吗，它可以将特殊字符转移成普通字符，也可以将普通字符转移成特殊字符，比如，**r**，没有任何特殊含义，那么转义下它， `\r`，它就表示回车字符了。 还有 `\` 本身是特殊字符，如果你想匹配它本身的话，那么就得转义它自己，`\\`，

   ```js
   /\\/.test('\\') // true
   /\\r/.test('\\r') // true
   ```

6. `\p{UnicodeProperty}`。可以算作之前的 `uhhhh` 等的 character class，匹配一类 unicode，比如匹配表情，

   ```js
   const sentence = "A ticket to 大阪 costs ¥2000 👌.";
   const regexpEmojiPresentation = /\p{Emoji_Presentation}/gu;
   console.log(sentence.match(regexpEmojiPresentation));
   // expected output: Array ["👌"]
   ```

   > Matches a character based on its [Unicode character properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes) (to match just, for example, emoji characters, or Japanese katakana characters, or Chinese/Japanese Han/Kanji characters, etc.).

   详细的定义如下，

   > Unicode property escapes Regular Expressions allows for matching characters based on their Unicode properties. A character is described by several properties which are either binary ("boolean-like") or non-binary. For instance, unicode property escapes can be used to match emojis, punctuations, letters (even letters from specific languages or scripts), etc.

   用法定义如下，

   ```js
   // Non-binary values
   \p{UnicodePropertyValue}
   \p{UnicodePropertyName=UnicodePropertyValue}

   // Binary and non-binary values
   \p{UnicodeBinaryPropertyName}

   // Negation: \P is negated \p
   \P{UnicodePropertyValue}
   \P{UnicodeBinaryPropertyName}
   ```

   详细介绍请参考，[Unicode property escapes - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes)。

7. `[\b]`。**b** 这个字符和 **.** 字符比较特殊，它们俩在 `[xyz]` 操作符中表示字面量，不过也不常用，定义如下。

   > Matches a backspace. If you're looking for the word-boundary character (\b), see Assertions.

   ```js
   /[\b]/.test('\x08') // true
   /[\b]/.test('\b') // true
   ```

8. `\0`。 不常用。

   > Matches a NUL character. Do not follow this with another digit.

   ```js
   /[\0]/.test("\0"); // true
   ```

9. `\cX`。不常用。

   > Matches a control character using [caret notation], where "X" is a letter from A–Z (corresponding to codepoints U+0001–U+001A). For example, /\cM\cJ/ matches "\r\n".

   ```js
   "\r\n".match(/\cM\cJ/g); // ['\r\n']
   ```

到此模糊匹配的教程就结束了。

## 精确匹配

根据目标字符串加上额外的匹配条件来精确匹配目标字符。比如我想匹配 **hot** 的 **o**，而不是 **dog** 的 **o**，我们就需要用 **o** 字符前后的字符（串）作为额外的匹配条件来进行精确匹配。

```js
/(?<=h)o(?=t)/.test('hot') // true // 专门用来匹配 hot
/(?<=h)o(?=t)/.test('dog') // false
```

上面我们用到了 `x(?=y)` 和 `(?<=y)x` 这两个 [断言](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions)（assertions）操作符，来看下它们的定义，

1. `x(?=y)`。用目标字符 **x** 后面的字符（串）作为额外匹配条件，

   > Lookahead assertion: Matches "x" only if "x" is followed by "y".

2. `(?<=y)x`。用目标字符 **x** 前面的字符（串）作为额外匹配条件，

   > Lookbehind assertion: Matches "x" only if "x" is preceded by "y".

   但是看上去在写这篇文章的时候， safari 还不支持这个 `(negative) lookbehind assertion`操作符，会报错，

   ```js
   /(?<!h)o/.test("hot"); // SyntaxError: Invalid regular expression: invalid group specifier name
   ```

记法小窍门：`(?<=y)x` 操作符里有一个 ** \<** 符号，你将它理解为向左看就很好极了。

上面说的都是等于的情况，当你不想匹配某一个条件的时候，可以使用 `x(?!y)` 和 `(?<!y)x` 操作符，

1. `x(?!y)`。

   > Negative lookahead assertion: Matches "x" only if "x" is not followed by "y".

2. `(?<!y)x`。

   > Negative lookbehind assertion: Matches "x" only if "x" is not preceded by "y".

```js
/(?<!h)o(?!t)/.test('hot') // true // 除了 hot 的 o 不匹配，其他的 o 都匹配
/(?<!h)o(?!t)/.test('dog') // true
```

记法小窍门：把 **=** 替换成 **!** 就可以了。

---

你还可以有这种操作，比如匹配位于单词中间，开头或者是末尾的字符（串），涉及到的两个操作符分别是 `\b` 和 `\B`，

`\b`。一般用来匹配单词的开头或者末尾的字符（串），[定义如下](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions)，

> Matches a word boundary. This is the position where a word character is not followed or preceded by another word-character, such as between a letter and a space. Note that a matched word boundary is not included in the match. In other words, the length of a matched word boundary is zero.

```js
/\bmoo/.test('moon') // true
/oon\b/.test('oon') // true
/moo\b/.test('moon') // false
/moon\b/.test('mooncake') // false
```

其实看下名字就比较好理解了，**word boundary**，如何决定一个单词的边界呢？我们把单词用一个最小的长方形框起来，那么左边和右边的边框就是 **word boundary** 了。

`\B`。一般用来匹配单词里的字符（串），[定义如下](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions)，

> Matches a non-word boundary. This is a position where the previous and next character are of the same type: Either both must be words, or both must be non-words, for example between two letters or between two spaces. The beginning and end of a string are considered non-words. Same as the matched word boundary, the matched non-word boundary is also not included in the match.

这里有一点也要注意下， ** The beginning and end of a string are considered non-words**，要熟悉游戏规则！！！

```js
/\B /.test('  ') // true
/\B/.test(' ') // true
/\B/.test('') // true
/moo\B/.test('moon') // true
```

到此精确匹配一个字符的讲解就结束了。

### String

到此，您应该已经是 character matching master 了。有了上面的基础，匹配字符串就好说了，字符串，顾名思义，就是一串字符。

```js
/aaa/.test('aaa') //true
/abc/.test('abc') //true
/aaaaaaaaaa/.test('aaaaaaaaaa') // true
```

我们匹配 3 个 **a**，10 个 **a**，这种有规律的字符串，我们可以使用 [量词](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Quantifiers) 操作符，它是字符串中最常用的操作符了，比如上面的操作我们可以用 `x{n}` 操作符来实现，**n** 必须是正整数，先来看下定义，

> Where "n" is a positive integer, matches exactly "n" occurrences of the preceding item "x".

```js
/a{3}/.test('aaa') //true
/a{10}/.test('aaaaaaaaaa') //true
/a{4}/.test('aaa') //false
/a{0}/.test('aaa') // always true // n 必须是正整数
```

那 **abc** 呢？也有规律，都是字母啊，我们可以用 **character class**，

```js
/[abc]{3}/.test('abc') //true
/[abc]{3}/.test('aac') //true
```

这里要注意下，上面量词定义里面提到的 **item**，它不单单可以指某一特定字符，比如 **a**，也可以指一类字符，比如，`[abc]` 这样，来看下来自 MDN 对于量词定义中出现的 **item** 的注解，

> Note: In the following, item refers not only to singular characters, but also includes character classes, Unicode property escapes, groups and ranges.

上面只是匹配 3 次，我们也可以给个区间，比如匹配 3-5 次都 OK，可以使用 `x{n,m}` 操作符，定义如下，

> Where "n" is 0 or a positive integer, "m" is a positive integer, and m > n, matches at least "n" and at most "m" occurrences of the preceding item "x".

```js
/a{1,5}/.test('') //false
/a{0,5}/.test('') //true
```

当然你也可以用 `x{n,}` 来缺省最大可匹配次数，表示至少需要匹配 **n** 次，最多匹配多少次都可以，但是要求 **n** 是正整数，来看下定义，

> Where "n" is a positive integer, matches at least "n" occurrences of the preceding item "x".

```js
/a{1,}/.test('') // false
/a{1,}/.test('a') // true
/a{0,}/.test('a') // always true // n 必须是正整数
```

`x+` 和 上面的 `{1,}` 操作符效果一样，来看下定义，

> Matches the preceding item "x" 1 or more times. Equivalent to {1,}.

```js
/a+/.test("") / // false
  a +
  /.test('a') / / true;
```

`x*` 操作符可以解决上面 `{n,m}` 操作符缺省 **m** 时，**n** 等于 **0** 会导致结果不正确的问题，虽然你可以理解为 `{0,}`，但是 `{0,}` 这个表达式是无效的，来看下定义，

> Matches the preceding item "x" 0 or more times.

`x?` 这个操作符在 `x*` 的基础上定义了一个最大值 **1**，虽然你可以理解为 `{0,1}`，但是 `{0,1}` 这个表达式是无效的，来看下定义，

> Matches the preceding item "x" 0 or 1 times. For example, /e?le?/ matches the "el" in "angel" and the "le" in "angle."

等下 ！！！

`x?` 这个操作符还有一个特别的用途，对，就是让前面讲到的 **4** 种量词操作符 `*`,`+`,`?`,`{}` 变得 non-greedy，就是在满足情况的情况下，尽量匹配的少，来看下定义，

> If used immediately after any of the quantifiers \*, +, ?, or {}, makes the quantifier non-greedy (matching the minimum number of times), as opposed to the default, which is greedy (matching the maximum number of times).

比如，我们匹配 es6 模版字符串的话，你可能会这样写，

```js
/\$\{.+\}/g.test("abc${abc}${xyz}xyz"); // true
"abc${abc}${xyz}xyz".match(/\$\{.+\}/g); // ['${abc}${xyz}']
```

这样看上去没问题，但是你看匹配结果你会发现它只匹配了一个模版字符串，就是 `${abc}${xyz}` 这么一整串，因为 `abc}${xyz` 这个可以算作是模版字符串的内容啊，不是吗？正确的写法，利用 `?` 操作符，让匹配 non-greedy，

```js
/\$\{.+?\}/g.test("abc${abc}${xyz}xyz"); // true
"abc${abc}${xyz}xyz".match(/\$\{.+?\}/g); // ['${abc}', '${xyz}']
```

`?` 操作符配合其他量词操作符一共有 6 种组合，

```js
x*?
x+?
x??
x{n}?
x{n,}?
x{n,m}?
```

> By default quantifiers like \* and + are "greedy", meaning that they try to match as much of the string as possible. The ? character after the quantifier makes the quantifier "non-greedy": meaning that it will stop as soon as it finds a match.

来看下例子，

```js
"abccccccc".match(/abc*/g); // ['abccccccc']
"abccccccc".match(/abc*?/g); // ['ab'] // 匹配 0 个 c
"abccccccc".match(/abc+/g); // ['abccccccc']
"abccccccc".match(/abc+?/g); // ['abc'] // 匹配 1 个 c
"abccccccc".match(/abc?/g); // ['abc']
"abccccccc".match(/abc??/g); // ['ab'] // 匹配 0 个 c
"abccccccc".match(/abc{1}/g); // ['abc']
"abccccccc".match(/abc{1}?/g); // ['abc'] // 效果一样
"abccccccc".match(/abc{1,}/g); // ['abccccccc']
"abccccccc".match(/abc{1,}?/g); // ['abc'] // 匹配 1 个 c
"abccccccc".match(/abc{1,2}/g); // ['abcc']
"abccccccc".match(/abc{1,2}?/g); // ['abc'] // 匹配 1 个 c
```

上面讲到的其实都是量词的用法，字符串里匹配字面量还有一个操作符，`|`，让你可以用一条正则来匹配两个字面量，来看下定义，

> Matches either "x" or "y". For example, /green|red/ matches "green" in "green apple" and "red" in "red apple".

```js
/green|red/.test('green') // true
/green|red/.test('red') // true
```

这样看来 `|`，只能用来同时匹配多个字面量是吗，感觉用处不是很大啊，它本身是只有这个作用，但是 ！！！对又是一个但是，它和别的操作符搭配起来可以变得更强大，比如我们想匹配 **hot** 或者 **hat**，

```js
"hot".match(/ho|at/g); // ['ho']
"hot".match(/hot|hat/g); // ['hot']
"hat".match(/hot|hat/g); // ['hat']
```

因为 **hot** 和 **hat** 只差了一个字母，而单单使用 `|` 只能让我们匹配它左边或者右面的字符（串），有点头疼，有什么办法可以让 `|` 附带范围效果呢？比如，让 `|` 只匹配左边一个字符和右边一个字符，这样我们匹配 **hot** 或者 **hat** 就可以写成一开始的这样了 `'hot'.match(/ho|at/g)` ，

我们如果只匹配单个字符，那么我们可以用 `[xyz]` 操作符，将 **o** 和 **a** 归属到一个 character class 里面去，这样能达到预期效果，

```js
"hot".match(/h[o|a]t/g); // ['hot']
```

但是这还是不能满足我们的需求，这个时候就需要 `(x)` 操作符登场了，它能让你只匹配括号里面的东西，这样我们不就限制了匹配范围了吗？来看下定义，

> Capturing group: Matches x and remembers the match. For example, /(foo)/ matches and remembers "foo" in "foo bar".
> A regular expression may have multiple capturing groups. In results, matches to capturing groups typically in an array whose members are in the same order as the left parentheses in the capturing group. This is usually just the order of the capturing groups themselves. This becomes important when capturing groups are nested. Matches are accessed using the index of the result's elements ([1], ..., [n]) or from the predefined RegExp object's properties ($1, ..., $9).
> Capturing groups have a performance penalty. If you don't need the matched substring to be recalled, prefer non-capturing parentheses (see below).
> String.match() won't return groups if the /.../g flag is set. However, you can still use String.matchAll() to get all matches.

这样我们如果想将边界限制为 `|` 的左边一个字符，右边一个字符，我们就可以用括号将左边一个字符加`|`加右边一个字符括起来，这样就限制了范围，感觉有点像 CSS 里面的 **overflow** 的效果，

```js
"hot".match(/h(o|a)t/g); // ['hot']
"bloody".match(/bloo(dy|d)/g); // ['bloody']
"blood".match(/bloo(dy|d)/g); // ['blood']
```

上面我们只是用到了 `(x)` 的一种用法，**match**，它还有 **remember** 的作用，来我们重新看下定义，

> Capturing group: Matches x and remembers the match. For example, /(foo)/ matches and remembers "foo" in "foo bar".

`(x)` 虽然可以记住匹配了什么，但我们还需要一种机制来引用它记住的值，JavaScript 里面的一些和正则表达式配套的函数可以提供一种机制让你引用它记住的值，就拿 `String.prototype.replace()` [函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter)来说，它接受两个参数，当 ** replace** 函数第一个入参为正则表达式的时候，如果第二个入参是一个函数的话，那么这个函数会默认接收到几个入参，包括 `(x)` 操作符记住的值的入参，让你可以引用它记住的字符（串），看下例子，

```js
function replacer(match, p1, p2, p3, offset, string, groups) {
  return [p1, p2, p3].join(" - ");
}
let newString = "abc12345#$*%".replace(/([^\d]*)(\d*)([^\w]*)/, replacer);
console.log(newString); // abc - 12345 - #$*%
```

因为我们使用了 `(x)` 操作符，所以，我们就可以用 **p1** 引用 `([^\d]*)` 匹配到的字符串，用 **p2** 引用 `(\d*)` 匹配到的字符串，以此类推，p1，p2，p3 的参数数量是由我们使用了多少个 `(x)` 操作符决定的。当然这个函数还有一些其他的参数供我们使用，比如第一个参数表示 match 到的字符串等。

关于 **remember**/**capture** 的用法的话，上面我们是通过 replacer 函数给的入参，比如，**p1**，**p2**，**p3** 等参数来引用 `(x)` 记住的值，要是我们需要引用一个值在很后面，比如我们写了 10 个 `(x)`，然后我们碰巧需要第一个记住的值 **p10**，那么我们函数的入参不是要写的很长很长了吗，像这样，

```js
function replacer(
  match,
  p1,
  p2,
  p3,
  p4,
  p5,
  p6,
  p7,
  p8,
  p9,
  p10,
  offset,
  string,
  groups
) {}
```

所以正则表达式还提供了一种方式让你直接引用到 **p10** 的值，就是 ** Named capturing group**，`(?<Name>x)`。

之前，我们如果需要引用捕获（captured/remembered）的值的话，你得通过 `p1`,`p2`… 按序号来引用，现在，你还可以直接通过名字来引用，来看下定义，

> Named capturing group: Matches "x" and stores it on the groups property of the returned matches under the name specified by <Name>. The angle brackets (< and >) are required for group name.

之前的例子可以改写成，

```js
function replacer(match, p1, offset, string, groups) {
  return groups.area;
}
let areaCode = "(205)".replace(/\((?<area>\d\d\d)\)/, replacer);
console.log(areaCode); // 205
```

当然除了 JavaScript 提供的配套函数可以让我们引用捕获的值，我们还可以直接在**正则表达式**里面引用我们捕获的值，高级 ！！！

要在正则里面引用捕获的值，需要用到 `\n` 操作符，用来引用第 **n** 个 capturing group 捕获/记住的值，[定义如下](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges)，

> Where "n" is a positive integer. A back reference to the last substring matching the n parenthetical in the regular expression (counting left parentheses). For example, /apple(,)\sorange\1/ matches "apple, orange," in "apple, orange, cherry, peach".

举个例子，比如我们用一个正则表达式同时匹配，**1**，**22**，**333**，**4444**，这 4 组字符串，怎么做呢？观察下可以发现，其实就是第一个数字重复了几遍，我们自然而然就会想到 `{n,m}` 量词操作符，试一下，

```js
"1".match(/\d{1,}/g); // ['1']
"22".match(/\d{1,}/g); // ['22']
"333".match(/\d{1,}/g); // ['333']
"4444".match(/\d{1,}/g); // ['4444']
```

完美！！！

但是这个也可以匹配上 ！！！ Not something that we wanted…

```js
"1234".match(/\d{1,}/g); // ['1234']
```

我们需要固定第一位数字，后面重复的都是刚才固定的那个数字，这个时候，就轮到我们的 `\n` 操作符出场了，

```js
"4444".match(/(\d)\1*/g); // ['4444']
"1234".match(/(\d)\1*/g); // ['1', '2', '3', '4'] not ['1234']
```

`(\d)` 会匹配一个数字，然后 `\1` 表示 `(\d)` 匹配到的字符（串），这样我们有了一个确定的字符（串）后，这样配合量词使用就可以达到我们想要的效果了，完美！！！

上面的引用其实就是 **p1**，**p2**，**p3**… 这种 index 引用，配合 ** capturing group**，对于过长的 index，引用起来就比较麻烦了。这里我们可以使用 ** named capturing group**，但是我们还需要一个操作符，配合着一起食用，这个操作符就是 `\k<Name>`，来看下定义，

> A back reference to the last substring matching the Named capture group specified by <Name>.

```js
"4444".match(/(?<number>\d)\k<number>*/g); // ['4444']
"22".match(/(?<number>\d)\k<number>*/g); // ['22']
"12".match(/(?<number>\d)\k<number>*/g); // ['1','2']
```

Nice ！！！

还记得最初的时候，我们因为给 `|` 添加范围限制的时候，使用了 `(x)` 操作符吗，因为 `(x)` 操作符的捕获/记住功能会有性能问题，而且那时候我们也不需要捕获功能，我们只需要范围限制功能（match）功能就行了，所以为了提升性能，我们可以使用 `(?:x)` 操作符，只匹配，不捕获，来看下定义，

> Non-capturing group: Matches "x" but does not remember the match. The matched substring cannot be recalled from the resulting array's elements ([1], ..., [n]) or from the predefined RegExp object's properties ($1, ..., $9).

```js
"hot".match(/h(?:o|a)t/g); // ['hot']
"bloody".match(/bloo(?:dy|d)/g); // ['bloody']
"blood".match(/bloo(?:dy|d)/g); // ['blood']
```

### Flag

在上面正则的学习过程中，我们已经遇到了两个 **flag**，**u** 和 **g**。flag 在使用上吗没有顺序之分，比如 `/a/gu` 和 `/a/ug` 作用是完全一样的。

flag 的用法如下，

```js
var re = /pattern/flags;
```

这里再重新学习下，

1. **g**。正常什么 flag 都不加，只会让我们匹配到第一个匹配的值。但是加了 **g** flag 的话，会让我们匹配到所有的值。

   > Global search.

```js
"hackers&painters".match(/a/); // ['a', index: 1, input: 'hackers&painters', groups: undefined]
"hackers&painters".match(/a/g); // ['a', 'a']
```

2. **u**。 匹配 unicode code point 的时候一定要带上的 flag，不然 `\u{hhhh}` 就没有匹配 unicode 的作用了，因为感觉不加 **u** flag 的话，会和 `{n,m}` 操作符冲突不是吗？

   来温故下 `\u{hhhh}` 的定义，

   > (Only when the u flag is set.) Matches the character with the Unicode value U+hhhh or U+hhhhh (hexadecimal digits).

   再来看下 **u** flag 的定义，

   > "unicode"; treat a pattern as a sequence of unicode code points.

   ```js
   /\u{0041}/.test("A"); // true
   ```

下面来学习下新的 flag，

1. **i**。Case-insensitive 的 **i**。

   我们在搜索的时候，比如用 `String.prototype.match` 函数，可以进行大小写不敏感的搜索，就可以利用 `i` 这个 flag，来看下它的定义，

   > Case-insensitive search.

   ```js
   /[abc]/i.test("A") / // true
     [abc] /
     i.test("a"); // true
   ```

2. **m**。多行匹配。定义如下，

   > Multi-line search.

   虽然我们使用 **g** 也可以在多行中对字符进行匹配，但是，**g** 匹配的时候会算作单行进行匹配，如，

   ```js
   /^football/g.test(`rugby
   
   football`); // false
   ```

   明明 football 确实是第三行的句子开头，但是匹配不到，使用 **m** flag 就可以解决这个问题，

   ```js
   /^football/gm.test(`rugby

   football`) // true
   /football/.test('rugby\nfootball') // true
   /^football/.test('rugby\nfootball') // false
   /^football/m.test('rugby\nfootball') // true
   ```

3. **s**。

   还记得 `.` 操作符吗，它除了 **line terminators** 不会匹配，其他所有的字符都可以匹配，而，`s` flag，可以让它，真正的匹配所有的字符，定义如下，

   > Allows . to match newline characters.

   ```js
   "a\b"
     .match(/./g)(
       // ['a', 'b'] // 没有 \n 换行符 line terminators
       "a\nb"
     )
     .match(/./gs); // ['a', '\n', 'b']
   ```

4. **y**。

   我们还可以指定从哪开始搜索，** g** 和 ** y** flag 都有这个作用，配合 `RegExp.prototype.lastIndex` 这个属性，但是两者还是略微有点不同，先来看下 **g** flag 好了，每次匹配都是从上一个匹配的字符串的末尾字符的后一个字符所对应的 index 作为起点，

   ```js
   var re = /hot|dog/g;
   console.log(re.lastIndex); // 0
   re.exec("hotdoghot");
   // ['hot', index: 0, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 3
   re.exec("hotdoghot");
   // ['dog', index: 3, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 6
   re.exec("hotdoghot");
   // ['hot', index: 6, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 9
   re.exec("hotdoghot"); // null
   console.log(re.lastIndex); // 0
   ```

   我们可以通过改变 `RegExp.prototype.lastIndex` [这个值](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex)来修改匹配开始的位置，

   ```js
   var re = /hot|dog/g;
   console.log(re.lastIndex); // 0
   re.lastIndex = 1;
   re.exec("hotdoghot");
   // 因为 lastIndex 设置为了 1， 所以相当于在匹配 'otdoghot'，所以第一次匹配会匹配到 dog
   // ['dog', index: 3, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 6
   ```

   而 ** y** flag，要求你给的 ** lastIndex** 必须是下次匹配的字符串的第一个字符在字符串中的 index ，是前一个字符的 index 都不行，所以第一次跑下面的代码是啥都匹配不到的，

   ```js
   var re = /hot|dog/y;
   console.log(re.lastIndex); // 0
   re.lastIndex = 1;
   re.exec("hotdoghot"); // null
   console.log(re.lastIndex); // 0 // 因为匹配不到所以被重置为 0
   ```

   只有当你的 ** lastIndex** 是下次匹配的字符串的首字符的开头的字符的 index 才可以，

   ```js
   var re = /hot|dog/y;
   console.log(re.lastIndex); // 0
   re.lastIndex = 3;
   re.exec("hotdoghot"); // ['dog', index: 3, input: 'hotdoghot', groups: undefined]
   console.log(re.lastIndex); // 6
   ```

   实操好了，现在再来看下 **y** flag 的 定义，

   > Perform a "sticky" search that matches starting at the current position in the target string. See [sticky](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky).

5. **d** flag。最后一个 flag，可以用来查看匹配到字符（串） 的开始和结束的字符的 index，[定义如下](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)，

   > Generate indices for substring matches.

   ```js
   var re = /dog/d;
   re.exec("hotdoghot").indices[0]; // [3, 6]
   ```

到此所有的正则表达式的语法都介绍完了~

恭喜你可以挺到这边~

Thank for Reading~ 🎉

---

但是会使用 regex 仅仅只是第一步，理解背后的算法也是很重要的，比如如何用 JavaScript 实现写一个 captruing group 函数呢？

## 参考

1. [Regular Expressions Guide - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
2. [unicode.org](https://unicode.org/faq/utf_bom.html#gen0)
3. [Javascript string - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)
